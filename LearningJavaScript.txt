JavaScript
	快速入门
		JavaScript代码可以直接嵌在网页的任何地方，通常放在<head>中
		方法一：用<script>...</script>
			<html>
			<head>
				<script>
					alert('Hello World!');
				</script>
			</head>
			<body>
			  ...
			</body>
			</html>
		方法二：将JavaScript代码放到一个单独的.js文件，通过<script src="..."></script>引入这个文件
			<html>
			<head>
			  <script src="/static/js/abc.js"></script>
			</head>
			<body>
			  ...
			</body>
			</html>
		基础语法
			JavaScript严格区分大小写
			语法和Java语言类似，每个语句以;结束，语句块用{...}
			注意花括号{...}内的语句具有缩进，通常是4个空格；非必须，建议使用缩进，有助于理解代码层次
			{...}可以嵌套，嵌套层级没有限制，但是过多的嵌套会增加看懂代码的难度
			//开头直到行末的字符被视为行注释，/*...*/把多行字符包裹起来是块注释
		数据类型
			Number
				不区分整数和浮点数
					123
					0.456
					1.2345e3
					-99
					NaN
					Infinity
				有时候用十六进制表示整数更方便
					0xff00
					0xa5b4c3d2
			字符串
				单引号或者双引号括起来的任意文本
				如果'本身也是一个字符，那就可以用""括起来
				如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识
					'I\'m \"OK\"!';
				转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\
				ASCII字符可以以\x##形式的十六进制表示
					'\x41'; // 完全等同于 'A'
				用\u####表示一个Unicode字符
					'\u4e2d\u6587'; // 完全等同于 '中文'
				多行字符串
					多行字符串用\n写起来比较费事，最新的ES6标准新增了一种多行字符串的表示方法，用`...`表示
						`这是一个
						多行
						字符串`;
				模板字符串
					要把多个字符串连接起来，可以用+号连接
						var name = '小明';
						var age = 20;
						var message = '你好, ' + name + ', 你今年' + age + '岁了!';
						alert(message);
					有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串
						var name = '小明';
						var age = 20;
						var message = `你好, ${name}, 你今年${age}岁了!`;
						alert(message);
				操作字符串
					1，求字符串长度
						var s = 'Hello, world!';
						s.length; // 13
					2，获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始
						var s = 'Hello, world!';

						s[0]; // 'H'
						s[6]; // ' '
						s[7]; // 'w'
						s[12]; // '!'
						s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined
					特别注意
						字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果
							var s = 'Test';
							s[0] = 'X';
							alert(s); // s仍然为'Test'
					其他常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串
					3，把一个字符串全部变为大写toUpperCase
						var s = 'Hello';
						s.toUpperCase(); // 返回'HELLO'
					4，把一个字符串全部变为小写toLowerCase
						var s = 'Hello';
						var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower
						lower; // 'hello'
					5，搜索指定字符串出现的位置indexOf
						var s = 'hello, world';
						s.indexOf('world'); // 返回7
						s.indexOf('World'); // 没有找到指定的子串，返回-1
					6，返回指定索引区间的子串substring
						var s = 'hello, world'
						s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
						s.substring(7); // 从索引7开始到结束，返回'world'
						
						
			布尔值
				只有true、false两种值
				可以直接用true、false表示布尔值，也可以通过布尔运算计算出来
				&&，与运算，只有所有都为true，&&运算结果才是true
				||，或运算，只要其中有一个为true，||运算结果就是true
				!，非运算，是一个单目运算符，把true变成false，false变成true
				比较运算符
					>
					>=
					==
				注意
					1,
						==，自动转换数据类型再比较
							false == 0; //true
						===，不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较
							false === 0; //false
					2,
						NaN这个特殊的Number与所有其他值都不相等，包括它自己
							NaN === NaN; //false
						唯一能判断NaN的方法是通过isNaN()函数
							isNaN(NaN); //true
					3,
						注意浮点数的相等比较
							1 / 3 === (1 - 2 / 3); // false
						浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数
						要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值
							Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
			null和undefined
				null表示一个“空”的值
				它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而null表示“空”。
				undefined表示值未定义
				区分undefined和null的意义不大。大多数情况下，我们都应该用null
				undefined仅仅在判断函数参数是否传递的情况下有用。
			数组
				数组是一组按顺序排列的集合，集合的每个值称为元素
				JavaScript的数组可以包括任意数据类型
					[1, 2, 3.14, 'Hello', null, true];
				另一种创建数组的方法是通过Array()函数实现
					new Array(1, 2, 3); 
				数组的元素可以通过索引来访问，索引的起始值为0
				Array的长度，直接访问length属性
					var arr = [1, 2, 3.14, 'Hello', null, true];
					arr.length; // 6
					注意：直接给Array的length赋一个新的值会导致Array大小的变化
						var arr = [1, 2, 3];
						arr.length; // 3
						arr.length = 6;
						arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
						arr.length = 2;
						arr; // arr变为[1, 2]
					Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array
						var arr = ['A', 'B', 'C'];
						arr[1] = 99;
						arr; // arr现在变为['A', 99, 'C']
					注意：如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化
						var arr = [1, 2, 3];
						arr[5] = 'x';
						arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
					大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。
					在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界
				相关函数
					1，indexOf(搜索一个指定的元素的位置)
						var arr = [10, 20, '30', 'xyz'];
						arr.indexOf(10); // 元素10的索引为0
						arr.indexOf(20); // 元素20的索引为1
						arr.indexOf(30); // 元素30没有找到，返回-1
						arr.indexOf('30'); // 元素'30'的索引为2
					2，slice(截取Array的部分元素，然后返回一个新的Array)
						var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
						arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
						arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
						注意：slice()的起止参数包括开始索引，不包括结束索引
						不给slice()传递任何参数，它就会从头到尾截取所有元素
							var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
							var aCopy = arr.slice();
							aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
							aCopy === arr; // false
					3，push和pop(push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉)
						var arr = [1, 2];
						arr.push('A', 'B'); // 返回Array新的长度: 4
						arr; // [1, 2, 'A', 'B']
						arr.pop(); // pop()返回'B'
						arr; // [1, 2, 'A']
						arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
						arr; // []
						arr.pop(); // 空数组继续pop不会报错，而是返回undefined
						arr; // []
					4，unshift和shift(unshift()往Array的头部添加若干元素，shift()方法则把Array的第一个元素删掉)
						var arr = [1, 2];
						arr.unshift('A', 'B'); // 返回Array新的长度: 4
						arr; // ['A', 'B', 1, 2]
						arr.shift(); // 'A'
						arr; // ['B', 1, 2]
						arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
						arr; // []
						arr.shift(); // 空数组继续shift不会报错，而是返回undefined
						arr; // []
					5，sort(对当前Array进行排序)
						var arr = ['B', 'C', 'A'];
						arr.sort();
						arr; // ['A', 'B', 'C']
					6，reverse(反转)
						var arr = ['one', 'two', 'three'];
						arr.reverse(); 
						arr; // ['three', 'two', 'one']
					7，splice(修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素)
						var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
						// 从索引2开始删除3个元素,然后再添加两个元素:
						arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
						arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
						// 只删除,不添加:
						arr.splice(2, 2); // ['Google', 'Facebook']
						arr; // ['Microsoft', 'Apple', 'Oracle']
						// 只添加,不删除:
						arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
						arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
					8，concat(当前的Array和另一个Array连接起来，并返回一个新的Array)
						var arr = ['A', 'B', 'C'];
						var added = arr.concat([1, 2, 3]);
						added; // ['A', 'B', 'C', 1, 2, 3]
						arr; // ['A', 'B', 'C']
						注意：concat()方法并没有修改当前Array，而是返回了一个新的Array
						concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里
							var arr = ['A', 'B', 'C'];
							arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
					9，join(把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串)
						var arr = ['A', 'B', 'C', 1, 2, 3];
						arr.join('-'); // 'A-B-C-1-2-3'
						如果Array的元素不是字符串，将自动转换为字符串后再连接
				多维数组
					如果数组的某个元素又是一个Array，则可以形成多维数组
						var arr = [[1, 2, 3], [400, 500, 600], '-'];
												
					
			对象
				一组由键-值组成的无序集合
					var person = {
						name: 'Bob',
						age: 20,
						tags: ['js', 'web', 'mobile'],
						city: 'Beijing',
						hasCar: true,
						zipcode: null
					};
				对象的键都是字符串类型，值可以是任意数据类型，每个键又称为对象的属性
				获取一个对象的属性，我们用 对象变量.属性名 的方式
					person.name; // 'Bob'
					person.zipcode; // null
				如果属性名包含特殊字符，就必须用''括起来
					var xiaohong = {
						name: '小红',
						'middle-school': 'No.1 Middle School'
					};
					xiaohong的属性名middle-school不是一个有效的变量，就需要用''括起来。
					访问这个属性也无法使用.操作符，必须用['xxx']来访问
						xiaohong['middle-school']; // 'No.1 Middle School'
						xiaohong['name']; // '小红'
						xiaohong.name; // '小红'
				如果访问一个不存在的属性会返回什么呢？
					访问不存在的属性不报错，而是返回undefined
					var xiaoming = {
						name: '小明'
					};
					xiaoming.age; // undefined
				对象是动态类型，你可以自由地给一个对象添加或删除属性
					var xiaoming = {
						name: '小明'
					};
					xiaoming.age; // undefined
					xiaoming.age = 18; // 新增一个age属性
					xiaoming.age; // 18
					delete xiaoming.age; // 删除age属性
					xiaoming.age; // undefined
					delete xiaoming['name']; // 删除name属性
					xiaoming.name; // undefined
					delete xiaoming.school; // 删除一个不存在的school属性也不会报错
				如果我们要检测xiaoming是否拥有某一属性，可以用in操作符
					var xiaoming = {
						name: '小明',
						birth: 1990,
						school: 'No.1 Middle School',
						height: 1.70,
						weight: 65,
						score: null
					};
					'name' in xiaoming; // true
					'grade' in xiaoming; // false
				注意：如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的
					'toString' in xiaoming; // true
					因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性
				要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法
					var xiaoming = {
						name: '小明'
					};
					xiaoming.hasOwnProperty('name'); // true
					xiaoming.hasOwnProperty('toString'); // false
					
			变量
				用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头
				变量名也不能是JavaScript的关键字，如if、while等。
				声明一个变量用var语句
					var a; // 申明了变量a，此时a的值为undefined
					var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1
					var s_007 = '007'; // s_007是一个字符串
					var Answer = true; // Answer是一个布尔值true
					var t = null; // t的值是null
				变量名也可以用中文，但可能会引起麻烦
				使用等号=对变量进行赋值
				可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var声明一次
					var a = 123; // a的值是整数123
					a = 'ABC'; // a变为字符串
				变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言
				静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言
					int a = 123; // a是整数类型变量，类型用int声明
					a = "ABC"; // 错误：不能把字符串赋给整型变量
				和静态语言相比，动态语言更灵活
			strict模式
				JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量
				这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量
					i = 10; // i现在是全局变量
				在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果
				使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内，同名变量在不同的函数体内互不冲突
				为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式
				在strict模式下，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误
				启用strict模式的方法是在JavaScript代码的第一行写上：'use strict';
				不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript
					'use strict';
					// 如果浏览器支持strict模式，
					// 下面的代码将报ReferenceError错误:
					abc = 'Hello, world';
					alert(abc);
					
		条件判断
			使用if () { ... } else { ... }来进行条件判断
			else语句是可选的
			如果语句块只包含一条语句，那么可以省略{}；但是建议永远都要写上{}
			如果还要更细致地判断条件，可以使用多个if...else...的组合
				var age = 3;
				if (age >= 18) {
					alert('adult');
				} else if (age >= 6) {
					alert('teenager');
				} else {
					alert('kid');
				}
			注意，if...else...语句的执行特点是二选一，在多个if...else...语句中，如果某个条件成立，则后续就不再继续判断
			JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true
		循环
			JavaScript的循环有两种，一种是for循环，另一种while循环
			for
				通过初始条件、结束条件和递增条件来循环执行语句块
					var x = 0;
					var i;
					for (i=1; i<=10000; i++) {
						x = x + i;
					}
					x; // 50005000
				for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环
			for...in
				可以把一个对象的所有属性依次循环出来
					var o = {
						name: 'Jack',
						age: 20,
						city: 'Beijing'
					};
					for (var key in o) {
						alert(key); // 'name', 'age', 'city'
					}
				要过滤掉对象继承的属性，用hasOwnProperty()来实现
					var o = {
						name: 'Jack',
						age: 20,
						city: 'Beijing'
					};
					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							alert(key); // 'name', 'age', 'city'
						}
					}
				由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引
					var a = ['A', 'B', 'C'];
					for (var i in a) {
						alert(i); // '0', '1', '2'
						alert(a[i]); // 'A', 'B', 'C'
					}
					注意，for ... in对Array的循环得到的是String而不是Number
			while
				只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环
					比如我们要计算100以内所有奇数之和，可以用while循环实现
						var x = 0;
						var n = 99;
						while (n > 0) {
							x = x + n;
							n = n - 2;
						}
						x; // 2500
			do ... while
				和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件
					var n = 0;
					do {
						n = n + 1;
					} while (n < 100);
					n; // 100
				do { ... } while()循环体会至少执行1次
		Map和Set
			JavaScript的对象有个小问题，就是键必须是字符串.实际上Number或者其他数据类型作为键也是非常合理的
			为了解决这个问题，最新的ES6规范引入了新的数据类型Map
			Map
				一组键值对的结构，具有极快的查找速度
					var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
					m.get('Michael'); // 95
				初始化Map需要一个二维数组，或者直接初始化一个空Map
					var m = new Map(); // 空Map
					m.set('Adam', 67); // 添加新的key-value
					m.set('Bob', 59);
					m.has('Adam'); // 是否存在key 'Adam': true
					m.get('Adam'); // 67
					m.delete('Adam'); // 删除key 'Adam'
					m.get('Adam'); // undefined
				由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值覆盖
					var m = new Map();
					m.set('Adam', 67);
					m.set('Adam', 88);
					m.get('Adam'); // 88
			Set
				一组key的集合，但不存储value
				由于key不能重复，所以，在Set中，没有重复的key
				要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set
					var s1 = new Set(); // 空Set
					var s2 = new Set([1, 2, 3]); // 含1, 2, 3
				重复元素在Set中自动被过滤
					var s = new Set([1, 2, 3, 3, '3']);
					s; // Set {1, 2, 3, "3"}
				通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果
				通过delete(key)方法可以删除元素
					var s = new Set([1, 2, 3]);
					s; // Set {1, 2, 3}
					s.delete(3);
					s; // Set {1, 2}
		iterable
			遍历Array可以采用下标循环，遍历Map和Set就无法使用下标
			为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型
			具有iterable类型的集合可以通过新的for ... of循环来遍历
				var a = ['A', 'B', 'C'];
				var s = new Set(['A', 'B', 'C']);
				var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
				for (var x of a) { // 遍历Array
					alert(x);
				}
				for (var x of s) { // 遍历Set
					alert(x);
				}
				for (var x of m) { // 遍历Map
					alert(x[0] + '=' + x[1]);
				}
			for ... of循环和for ... in循环有何区别？
				for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称
					一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。
					当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果
					var a = ['A', 'B', 'C'];
					a.name = 'Hello';
					for (var x in a) {
						alert(x); // '0', '1', '2', 'name'
					}
					for ... in循环将把name包括在内，但Array的length属性却不包括在内
				for ... of循环则完全修复了这些问题，它只循环集合本身的元素
					var a = ['A', 'B', 'C'];
					a.name = 'Hello';
					for (var x of a) {
						alert(x); // 'A', 'B', 'C'
					}
			更好的方式是直接使用iterable内置的forEach方法
				以Array为例
					var a = ['A', 'B', 'C'];
					a.forEach(function (element, index, array) {
						// element: 指向当前元素的值
						// index: 指向当前索引
						// array: 指向Array对象本身
						alert(element);
					});
				Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身
					var s = new Set(['A', 'B', 'C']);
					s.forEach(function (element, sameElement, set) {
						alert(element);
					});
				Map的回调函数参数依次为value、key和map本身
					var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
					m.forEach(function (value, key, map) {
						alert(value);
					});
				如果对某些参数不感兴趣，可以忽略它们
					例如，只需要获得Array的element
						var a = ['A', 'B', 'C'];
						a.forEach(function (element) {
							alert(element);
						});
	
	函数
		代码抽象方式
		定义
			方式一
				function abs(x) {
					if (x >= 0) {
						return x;
					} else {
						return -x;
					}
				}
			function指出这是一个函数定义；
			abs是函数的名称；
			(x)括号内列出函数的参数，多个参数以,分隔；
			{ ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句
			函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回
			如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined
			函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量
			
			方式二
				var abs = function (x) {
					if (x >= 0) {
						return x;
					} else {
						return -x;
					}
				};
			在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名
			但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数
		函数调用
			JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数
				abs(10, 'blablabla'); // 返回10
				abs(-9, 'haha', 'hehe', null); // 返回9
			传入的参数比定义的少也没有问题
				abs(); // 返回NaN
				此时abs(x)函数的参数x将收到undefined，计算结果为NaN
				要避免收到undefined，可以对参数进行检查
					function abs(x) {
						if (typeof x !== 'number') {
							throw 'Not a number';
						}
						if (x >= 0) {
							return x;
						} else {
							return -x;
						}
					}
			arguments
				JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数
				arguments类似Array但它不是一个Array
					function foo(x) {
						alert(x); // 10
						for (var i=0; i<arguments.length; i++) {
							alert(arguments[i]); // 10, 20, 30
						}
					}
					foo(10, 20, 30);
				利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值
					function abs() {
						if (arguments.length === 0) {
							return 0;
						}
						var x = arguments[0];
						return x >= 0 ? x : -x;
					}

					abs(); // 0
					abs(10); // 10
					abs(-9); // 9
				实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法：
					// foo(a[, b], c)
					// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
					function foo(a, b, c) {
						if (arguments.length === 2) {
							// 实际拿到的参数是a和b，c为undefined
							c = b; // 把b赋给c
							b = null; // b变为默认值
						}
						// ...
					}
			rest
				ES6标准引入了rest参数，获得额外的rest参数
					function foo(a, b, ...rest) {
						console.log('a = ' + a);
						console.log('b = ' + b);
						console.log(rest);
					}

					foo(1, 2, 3, 4, 5);
					// 结果:
					// a = 1
					// b = 2
					// Array [ 3, 4, 5 ]

					foo(1);
					// 结果:
					// a = 1
					// b = undefined
					// Array []
				rest参数只能写在最后，前面用...标识
		变量作用域
			如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量
				'use strict';

				function foo() {
					var x = 1;
					x = x + 1;
				}

				x = x + 2; // ReferenceError! 无法在函数体外引用变量x
			如果两个不同的函数各自申明了同一个变量，它们互相独立，互不影响
				'use strict';

				function foo() {
					var x = 1;
					x = x + 1;
				}

				function bar() {
					var x = 'A';
					x = x + 'B';
				}
			函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行
				'use strict';

				function foo() {
					var x = 1;
					function bar() {
						var y = x + 1; // bar可以访问foo的变量x!
					}
					var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
				}
			如果内部函数和外部函数的变量名重名怎么办？
				函数在查找变量时从自身函数定义开始，从“内”向“外”查找
				如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量
			变量提升
				函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部
					'use strict';
					function foo() {
						var x = 'Hello, ' + y;
						alert(x);
						var y = 'Bob';
					}
					foo();
					语句var x = 'Hello, ' + y;并不报错，原因是变量y在稍后申明了
					但是alert显示Hello, undefined，说明变量y的值为undefined
					JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值
					严格遵守“在函数内部首先申明所有变量”这一规则
						function foo() {
							var
								x = 1, // x初始化为1
								y = x + 1, // y初始化为2
								z, i; // z和i为undefined
							// 其他语句:
							for (i=0; i<100; i++) {
								...
							}
						}
			全局作用域
				JavaScript默认有一个全局对象window
				全局作用域的变量实际上被绑定到window的一个属性
					'use strict';
					var course = 'Learn JavaScript';
					alert(course); // 'Learn JavaScript'
					alert(window.course); // 'Learn JavaScript'
				变量方式var foo = function () {}定义的函数实际上也是一个全局变量
				顶层函数的定义也被视为一个全局变量，并绑定到window对象
				每次直接调用的alert()函数其实也是window的一个变量
			名字空间
				不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突
				减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中
			局部作用域
				JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量
					'use strict';
					function foo() {
						for (var i=0; i<100; i++) {
							//
						}
						i += 100; // 仍然可以引用变量i
					}
				为了解决块级作用域，ES6引入了新的关键字let
				用let替代var可以申明一个块级作用域的变量
					'use strict';
					function foo() {
						var sum = 0;
						for (let i=0; i<100; i++) {
							sum += i;
						}
						i += 1; // SyntaxError
					}
			常量
				var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的
				通常用全部大写的变量来表示常量，不修改它的值
					var PI = 3.14;
				ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域
					'use strict';
					const PI = 3.14;
					PI = 3; // 某些浏览器不报错，但是无效果！
					PI; // 3.14
		方法
			在一个对象中绑定函数，称为这个对象的方法
				如果我们给xiaoming绑定一个函数
				var xiaoming = {
					name: '小明',
					birth: 1990,
					age: function () {
						var y = new Date().getFullYear();
						return y - this.birth;
					}
				};
				xiaoming.age; // function xiaoming.age()
				xiaoming.age(); // 今年调用是25,明年调用就变成26了
			绑定到对象上的函数称为方法，它在内部使用了一个this关键字
			对普通函数调用，我们通常把this绑定为null
			在一个方法内部，this是一个特殊变量，它始终指向当前对象
				function getAge() {
					var y = new Date().getFullYear();
					return y - this.birth;
				}

				var xiaoming = {
					name: '小明',
					birth: 1990,
					age: getAge
				};

				xiaoming.age(); // 25, 正常结果
				getAge(); // NaN
				如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象
				如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window
				如果这么写：
					var fn = xiaoming.age; // 先拿到xiaoming的age函数
					fn(); // NaN
				也是不行的
			要保证this指向正确，必须用obj.xxx()的形式调用！
			ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误
				'use strict';
				var xiaoming = {
					name: '小明',
					birth: 1990,
					age: function () {
						var y = new Date().getFullYear();
						return y - this.birth;
					}
				};
				var fn = xiaoming.age;
				fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
			这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置
			apply
				要指定函数的this指向哪个对象，可以用函数本身的apply方法
				接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数
					function getAge() {
						var y = new Date().getFullYear();
						return y - this.birth;
					}
					var xiaoming = {
						name: '小明',
						birth: 1990,
						age: getAge
					};
					xiaoming.age(); // 25
					getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
			call
				另一个与apply()类似的方法是call()
				区别
					apply()把参数打包成Array再传入；
					call()把参数按顺序传入
					
					比如调用Math.max(3, 5, 4)，分别用apply()和call()实现
						Math.max.apply(null, [3, 5, 4]); // 5
						Math.max.call(null, 3, 5, 4); // 5
			装饰器
				JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数
				现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了
				最佳方案是用我们自己的函数替换掉默认的parseInt()
					var count = 0;
					var oldParseInt = parseInt; // 保存原函数

					window.parseInt = function () {
						count += 1;
						return oldParseInt.apply(null, arguments); // 调用原函数
					};

					// 测试:
					parseInt('10');
					parseInt('20');
					parseInt('30');
					count; // 3
		高阶函数
			一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数
			高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回
				function add(x, y, f) {
					return f(x) + f(y);
				}
				当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs
				add(-5, 6, Math.abs); // 11
			map/reduce
				map
					map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果
						function pow(x) {
							return x * x;
						}

						var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
						arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
					map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数
						var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
						arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
				reduce
					Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算
						[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
						对一个Array求和
							var arr = [1, 3, 5, 7, 9];
							arr.reduce(function (x, y) {
								return x + y;
							}); // 25
						要把[1, 3, 5, 7, 9]变换成整数13579
							var arr = [1, 3, 5, 7, 9];
							arr.reduce(function (x, y) {
								return x * 10 + y;
							}); // 13579
						不要使用JavaScript内置的parseInt()和Number()函数，利用map和reduce操作实现一个string2int()函数
							'use strict';
							function string2int(s) {
								return s.split('').map(function (x) { return x - '0';}).reduce(function(x, y) {return x * 10 + y});
							}
							// 测试:
							if (string2int('0') === 0 && string2int('12345') === 12345 && string2int('12300') === 12300) {
								if (string2int.toString().indexOf('parseInt') !== -1) {
									alert('请勿使用parseInt()!');
								} else if (string2int.toString().indexOf('Number') !== -1) {
									alert('请勿使用Number()!');
								} else {
									alert('测试通过!');
								}
							}
							else {
								alert('测试失败!');
							}
						把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字
						输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']
							'use strict';
							function normalize(arr) {
								return arr.map(function(x) { var head = x[0].toUpperCase(); var tail = x.substring(1).toLowerCase(); return head + tail;});
							}
							// 测试:
							if (normalize(['adam', 'LISA', 'barT']).toString() === ['Adam', 'Lisa', 'Bart'].toString()) {
								alert('测试通过!');
							}
							else {
								alert('测试失败!');
							}
						利用map()把字符串变成整数
							'use strict';
							var arr = ['1', '2', '3'];
							var r;
							r = arr.map(parseInt);
							alert('[' + r[0] + ', ' + r[1] + ', ' + r[2] + ']');
							结果竟然是[1, NaN, NaN]。
							原因
								由于map()接收的回调函数可以有3个参数：callback(currentValue, index, array)，通常我们仅需要第一个参数，而忽略了传入的后面两个参数
								不幸的是，parseInt(string, radix)没有忽略第二个参数
								实际执行的函数分别是：
									parseInt('1', 0); // 0, 按十进制转换
									parseInt('2', 1); // NaN, 没有一进制
									parseInt('3', 2); // NaN, 按二进制转换不允许出现3
							可以改为r = arr.map(Number);，因为Number(value)函数仅接收一个参数
							或者
								r = arr.map(function(x) { return +x;});
								js 是一种弱类型的语言，执行 +x 时会进行隐式的转换
			filter
				用于把Array的某些元素过滤掉，然后返回剩下的元素
				Array的filter()也接收一个函数，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素
				例如，在一个Array中，删掉偶数，只保留奇数
					var arr = [1, 2, 4, 5, 6, 9, 10, 15];
					var r = arr.filter(function (x) {
						return x % 2 !== 0;
					});
					r; // [1, 5, 9, 15]
				把一个Array中的空字符串删掉
					var arr = ['A', '', 'B', null, undefined, 'C', '  '];
					var r = arr.filter(function (s) {
						return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
					});
					r; // ['A', 'B', 'C']
				用filter()筛选出素数
					function get_primes(arr) {
						function isPrime(x){
							if(!Number.isInteger(x)||x<=1) return false;
							for(var i=2;i<=Math.sqrt(x);i++){
								if(x%i==0) return false
							};
							return true;
						}
						return arr.filter(isPrime);
					}
					
					// 测试:
					var
						x,
						r,
						arr = [];
					for (x = 1; x < 100; x++) {
						arr.push(x);
					}
					r = get_primes(arr);
					if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) {
						alert('测试通过!');
					} else {
						alert('测试失败: ' + r.toString());
					}
			sort
				通常规定，对于两个元素x和y，如果认为x < y，则返回-1，如果认为x == y，则返回0，如果认为x > y，则返回1
				这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序
				Array的sort()方法用于排序
					// 看上去正常的结果:
					['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

					// apple排在了最后:
					['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']
					// 因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后

					// 无法理解的结果:
					[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
					// Array的sort()方法默认把所有元素先转换为String再排序
				sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序
					按数字大小排序
						var arr = [10, 20, 1, 2];
						arr.sort(function (x, y) {
							if (x < y) {
								return -1;
							}
							if (x > y) {
								return 1;
							}
							return 0;
						}); // [1, 2, 10, 20]
					要倒序排序，我们可以把大的数放前面
						var arr = [10, 20, 1, 2];
						arr.sort(function (x, y) {
							if (x < y) {
								return 1;
							}
							if (x > y) {
								return -1;
							}
							return 0;
						}); // [20, 10, 2, 1]
					忽略大小写，按照字母序排序
					忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较
						var arr = ['Google', 'apple', 'Microsoft'];
						arr.sort(function (s1, s2) {
							x1 = s1.toUpperCase();
							x2 = s2.toUpperCase();
							if (x1 < x2) {
								return -1;
							}
							if (x1 > x2) {
								return 1;
							}
							return 0;
						}); // ['apple', 'Google', 'Microsoft']
					注意：sort()方法会直接对Array进行修改，它返回的结果仍是当前Array
						var a1 = ['B', 'A', 'C'];
						var a2 = a1.sort();
						a1; // ['A', 'B', 'C']
						a2; // ['A', 'B', 'C']
						a1 === a2; // true, a1和a2是同一对象
		闭包
			闭包就是能够读取其他函数内部变量的函数
				在Javascript语言中，只有函数内部的子函数才能读取局部变量
				因此可以把闭包简单理解成"定义在一个函数内部的函数"
			在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁
			闭包的用途
				一个是可以读取函数内部的变量
				另一个就是让这些变量的值始终保持在内存中
			使用闭包需注意
				由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，不能滥用
				闭包会在父函数外部，改变父函数内部变量的值
			实现一个对Array的求和
				通常情况
					function sum(arr) {
						return arr.reduce(function (x, y) {
							return x + y;
						});
					}
					sum([1, 2, 3, 4, 5]); // 15
				如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？
				可以不返回求和的结果，而是返回求和的函数
					function lazy_sum(arr) {
						var sum = function () {
							return arr.reduce(function (x, y) {
								return x + y;
							});
						}
						return sum;
					}
				当调用lazy_sum()时，返回的并不是求和结果，而是求和函数
					var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()
				调用函数f时，才真正计算求和的结果
					f(); // 15
					
			在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量
			当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为 闭包
			注意：调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数
				var f1 = lazy_sum([1, 2, 3, 4, 5]);
				var f2 = lazy_sum([1, 2, 3, 4, 5]);
				f1 === f2; // false
				f1()和f2()的调用结果互不影响
				
			返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量
				function count() {
					var arr = [];
					for (var i=1; i<=3; i++) {
						arr.push(function () {
							return i * i;
						});
					}
					return arr;
				}
				var results = count();
				var f1 = results[0];
				var f2 = results[1];
				var f3 = results[2];
				
				f1(); // 16
				f2(); // 16
				f3(); // 16
				原因就在于返回的函数引用了变量i，但它并非立刻执行。
				等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16
				
			在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量
			在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量
			用JavaScript创建一个计数器
				'use strict';
				function create_counter(initial) {
					var x = initial || 0;
					return {
						inc: function () {
							x += 1;
							return x;
						}
					}
				}
				var c1 = create_counter();
				c1.inc(); // 1
				c1.inc(); // 2
				c1.inc(); // 3

				var c2 = create_counter(10);
				c2.inc(); // 11
				c2.inc(); // 12
				c2.inc(); // 13
			在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。
			换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来
			
			脑洞大开
				阿隆佐・邱奇 发现只需要用函数，就可以用计算机实现运算，而不需要0、1、2、3这些数字和+、-、*、/这些符号
					'use strict';
					// 定义数字0:
					var zero = function (f) {
						return function (x) {
							return x;
						}
					};

					// 定义数字1:
					var one = function (f) {
						return function (x) {
							return f(x);
						}
					};

					// 定义加法:
					function add(n, m) {
						return function (f) {
							return function (x) {
								return m(f)(n(f)(x));
							}
						}
					}
					// 计算数字2 = 1 + 1:
					var two = add(one, one);

					// 计算数字3 = 1 + 2:
					var three = add(one, two);

					// 计算数字5 = 2 + 3:
					var five = add(two, three);

					// 给3传一个函数,会打印3次:
					(three(function () {
						console.log('print 3 times');
					}))();

					// 给5传一个函数,会打印5次:
					(five(function () {
						console.log('print 5 times');
					}))();
		箭头函数
			ES6标准新增了一种新的函数：Arraw Function（箭头函数）
				x => x * x
				相当于：
				function (x) {
					return x * x;
				}
			箭头函数相当于匿名函数，并且简化了函数定义
			箭头函数有两种格式
				只包含一个表达式，连{ ... }和return都省略掉
				还有一种可以包含多条语句，这时候就不能省略{ ... }和return
					x => {
						if (x > 0) {
							return x * x;
						}
						else {
							return - x * x;
						}
					}
				如果参数不是一个，就需要用括号()括起来
					// 两个参数:
					(x, y) => x * x + y * y

					// 无参数:
					() => 3.14

					// 可变参数:
					(x, y, ...rest) => {
						var i, sum = x + y;
						for (i=0; i<rest.length; i++) {
							sum += rest[i];
						}
						return sum;
					}
				如果要返回一个对象，如果是单表达式，这么写的话会报错
					// SyntaxError:
					x => { foo: x }
				改为：
					// ok:
					x => ({ foo: x })
			箭头函数内部的this是词法作用域，由上下文确定
				var obj = {
					birth: 1990,
					getAge: function () {
						var b = this.birth; // 1990
						var fn = function () {
							return new Date().getFullYear() - this.birth; // this指向window或undefined
						};
						return fn();
					}
				};
				箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj
					var obj = {
						birth: 1990,
						getAge: function () {
							var b = this.birth; // 1990
							var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
							return fn();
						}
					};
					obj.getAge(); // 25
				由于this在箭头函数中已经按照词法作用域绑定了
				所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略
					var obj = {
						birth: 1990,
						getAge: function (year) {
							var b = this.birth; // 1990
							var fn = (y) => y - this.birth; // this.birth仍是1990
							return fn.call({birth:2000}, year);
						}
					};
					obj.getAge(2015); // 25
		generator
			generator（生成器）是ES6标准引入的新的数据类型
			一个generator看上去像一个函数，但可以返回多次
			generator跟函数很像，定义如下：
				function* foo(x) {
					yield x + 1;
					yield x + 2;
					return x + 3;
				}
			generator和函数不同的是，generator由function*定义
			除了return语句，还可以用yield返回多次
			要编写一个产生斐波那契数列的函数
				function fib(max) {
					var
						t,
						a = 0,
						b = 1,
						arr = [0, 1];
					while (arr.length < max) {
						t = a + b;
						a = b;
						b = t;
						arr.push(t);
					}
					return arr;
				}

				// 测试:
				fib(5); // [0, 1, 1, 2, 3]
				fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
			函数只能返回一次，所以必须返回一个Array
			但是，如果换成generator，就可以一次返回一个数，不断返回多次
				function* fib(max) {
					var
						t,
						a = 0,
						b = 1,
						n = 1;
					while (n < max) {
						yield a;
						t = a + b;
						a = b;
						b = t;
						n ++;
					}
					return a;
				}
				fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
			调用generator对象有两个方法
				一是不断地调用generator对象的next()方法
					var f = fib(5);
					f.next(); // {value: 0, done: false}
					f.next(); // {value: 1, done: false}
					f.next(); // {value: 1, done: false}
					f.next(); // {value: 2, done: false}
					f.next(); // {value: 3, done: true}
					next()方法会执行generator的代码
					然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}
					然后“暂停”
					返回的value就是yield的返回值，done表示这个generator是否已经执行结束
					如果done为true，则value就是return的返回值
					当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()
				第二个方法是直接用for ... of循环迭代generator对象
					这种方式不需要我们自己判断done
						for (var x of fib(5)) {
							console.log(x); // 依次输出0, 1, 1, 2, 3
						}
			generator和普通函数相比，有什么用？
				因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数
				利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能
				generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码
	标准对象
		JavaScript的世界里，一切都是对象
		某些对象还是和其他对象不太一样
		用typeof操作符获取对象的类型，它总是返回一个字符串
			typeof 123; // 'number'
			typeof NaN; // 'number'
			typeof 'str'; // 'string'
			typeof true; // 'boolean'
			typeof undefined; // 'undefined'
			typeof Math.abs; // 'function'
			typeof null; // 'object'
			typeof []; // 'object'
			typeof {}; // 'object'
		包装对象
			number、boolean和string都有包装对象
			字符串也区分string类型和它的包装类型
			包装对象用new创建
				var n = new Number(123); // 123,生成了新的包装类型
				var b = new Boolean(true); // true,生成了新的包装类型
				var s = new String('str'); // 'str',生成了新的包装类型
			虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object
			包装对象和原始值用===比较会返回false
				typeof new Number(123); // 'object'
				new Number(123) === 123; // false

				typeof new Boolean(true); // 'object'
				new Boolean(true) === true; // false

				typeof new String('str'); // 'object'
				new String('str') === 'str'; // false
			如果我们在使用Number、Boolean和String时，没有写new会发生什么情况？
				此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型
				注意不是其包装类型
					var n = Number('123'); // 123，相当于parseInt()或parseFloat()
					typeof n; // 'number'

					var b = Boolean('true'); // true
					typeof b; // 'boolean'

					var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！
					var b3 = Boolean(''); // false

					var s = String(123.45); // '123.45'
					typeof s; // 'string'
			总结几条规则需要遵守：
				不要使用new Number()、new Boolean()、new String()创建包装对象；
				
				用parseInt()或parseFloat()来转换任意类型到number；

				用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；

				通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}；

				typeof操作符可以判断出number、boolean、string、function和undefined；

				判断Array要使用Array.isArray(arr)；

				判断null请使用myVar === null；

				判断某个全局变量是否存在用typeof window.myVar === 'undefined'；

				函数内部判断某个变量是否存在用typeof myVar === 'undefined'。
			任何对象都有toString()方法吗？
				null和undefined就没有
			number对象调用toString()报SyntaxError
				123.toString(); // SyntaxError
				遇到这种情况，要特殊处理一下
					123..toString(); // '123', 注意是两个点！
					(123).toString(); // '123'
		Date
			在JavaScript中，Date对象用来表示日期和时间
			获取系统当前时间
				var now = new Date();
				now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
				now.getFullYear(); // 2015, 年份
				now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
				now.getDate(); // 24, 表示24号
				now.getDay(); // 3, 表示星期三
				now.getHours(); // 19, 24小时制
				now.getMinutes(); // 49, 分钟
				now.getSeconds(); // 22, 秒
				now.getMilliseconds(); // 875, 毫秒数
				now.getTime(); // 1435146562875, 以number形式表示的时间戳
				注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值
			创建一个指定日期和时间的Date对象
				方法一
					var d = new Date(2015, 5, 19, 20, 15, 30, 123);
					d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)
					JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月……
					所以要表示6月，我们传入的是5
				方法二
					解析一个符合ISO 8601格式的字符串
					var d = Date.parse('2015-06-24T19:49:22.875+08:00');
					d; // 1435146562875
					它返回的不是Date对象，而是一个时间戳
					时间戳很容易地转换为一个Date
					var d = new Date(1435146562875);
					d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
			时区
				Date对象表示的时间总是按浏览器所在时区显示的
				既可以显示本地时间，也可以显示调整后的UTC时间
					var d = new Date(1435146562875);
					d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
					d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时
				在JavaScript中如何进行时区转换呢？
					只要我们传递的是一个number类型的时间戳，我们就不用关心时区转换。
					任何浏览器都可以把一个时间戳正确转换为本地时间
				时间戳
					时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。
					假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关
				获取当前时间戳
					if (Date.now) {
						alert(Date.now()); // 老版本IE没有now()方法
					} else {
						alert(new Date().getTime());
					}
		RegExp
			正则表达式
				正则表达式是一种用来匹配字符串的强有力的工具。
				设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的
					\d可以匹配一个数字
					\w可以匹配一个字母或数字
					.可以匹配任意字符
						'00\d'可以匹配'007'，但无法匹配'00A'
						'\d\d\d'可以匹配'010'
						'\w\w'可以匹配'js'
						'js.'可以匹配'jsp'、'jss'、'js!'等等
					*表示任意个字符（包括0个）
					+表示至少一个字符
					?表示0个或1个字符
					{n}表示n个字符
					{n,m}表示n-m个字符
						\d{3}\s+\d{3,8}
						匹配以任意个空格隔开的带区号的电话号码
					[]表示范围
						[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线
						[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串
							'a100'，'0_Z'，'js2015'等等
						[a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串
							也就是JavaScript允许的变量名
						[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）
						A|B可以匹配A或B
							(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'
						^表示行的开头
							^\d表示必须以数字开头
						$表示行的结束
							\d$表示必须以数字结束
			RegExp
				JavaScript有两种方式创建一个正则表达式
					第一种方式是直接通过/正则表达式/写出来
					第二种方式是通过new RegExp('正则表达式')创建一个RegExp对象
						var re1 = /ABC\-001/;
						var re2 = new RegExp('ABC\\-001');
						re1; // /ABC\-001/
						re2; // /ABC\-001/
						
						var re = /^\d{3}\-\d{3,8}$/;
						re.test('010-12345'); // true
						re.test('010-1234x'); // false
						re.test('010 12345'); // false
					RegExp对象的test()方法用于测试给定的字符串是否符合条件
				切分字符串
					'a b   c'.split(' '); // ['a', 'b', '', '', 'c']无法识别连续的空格
					用正则表达式
						'a b   c'.split(/\s+/); // ['a', 'b', 'c']
						'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
						'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
				分组
					正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）
						^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码
						var re = /^(\d{3})-(\d{3,8})$/;
						re.exec('010-12345'); // ['010-12345', '010', '12345']
						re.exec('010 12345'); // null
					如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来
					exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。
					exec()方法在匹配失败时返回null
				贪婪匹配
					正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符
						var re = /^(\d+)(0*)$/;
						re.exec('102300'); // ['102300', '102300', '']
						由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串
					加个?就可以让\d+采用非贪婪匹配
						var re = /^(\d+?)(0*)$/;
						re.exec('102300'); // ['102300', '1023', '00']
				全局搜索
					正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配
						var r1 = /test/g;
						// 等价于:
						var r2 = new RegExp('test', 'g');
					全局匹配可以多次执行exec()方法来搜索一个匹配的字符串
					当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引
						var s = 'JavaScript, VBScript, JScript and ECMAScript';
						var re=/[a-zA-Z]+Script/g;

						// 使用全局匹配:
						re.exec(s); // ['JavaScript']
						re.lastIndex; // 10

						re.exec(s); // ['VBScript']
						re.lastIndex; // 20

						re.exec(s); // ['JScript']
						re.lastIndex; // 29

						re.exec(s); // ['ECMAScript']
						re.lastIndex; // 44

						re.exec(s); // null，直到结束仍没有匹配到
					全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次
					正则表达式还可以指定i标志，表示忽略大小写；m标志，表示执行多行匹配
		JSON
			JavaScript Object Notation，数据交换格式
			道格拉斯・克罗克福特（Douglas Crockford）发明了JSON这种超轻量级的数据交换格式
			在JSON中，一共就这么几种数据类型：
				number：和JavaScript的number完全一致；
				boolean：就是JavaScript的true或false；
				string：就是JavaScript的string；
				null：就是JavaScript的null；
				array：就是JavaScript的Array表示方式――[]；
				object：就是JavaScript的{ ... }表示方式；
				以及上面的任意组合。
			JSON字符集必须是UTF-8
			为了统一解析，JSON的字符串规定必须用双引号""，Object的键也必须用双引号""
			JavaScript内置了JSON的解析
				把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串
				如果收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了
			序列化
				var xiaoming = {
					name: '小明',
					age: 14,
					gender: true,
					height: 1.65,
					grade: null,
					'middle-school': '\"W3C\" Middle School',
					skills: ['JavaScript', 'Java', 'Python', 'Lisp']
				};
				JSON.stringify(xiaoming); // '{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}'
				要输出得好看一些，可以加上参数，按缩进输出
					JSON.stringify(xiaoming, null, '  ');
					结果：
					{
					  "name": "小明",
					  "age": 14,
					  "gender": true,
					  "height": 1.65,
					  "grade": null,
					  "middle-school": "\"W3C\" Middle School",
					  "skills": [
						"JavaScript",
						"Java",
						"Python",
						"Lisp"
					  ]
					}
				第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array
					JSON.stringify(xiaoming, ['name', 'skills'], '  ');
					结果：
					{
					  "name": "小明",
					  "skills": [
						"JavaScript",
						"Java",
						"Python",
						"Lisp"
					  ]
					}
				还可以传入一个函数，这样对象的每个键值对都会被函数先处理
					function convert(key, value) {
						if (typeof value === 'string') {
							return value.toUpperCase();
						}
						return value;
					}
					JSON.stringify(xiaoming, convert, '  ');
					结果把所有属性值都变成大写
						{
						  "name": "小明",
						  "age": 14,
						  "gender": true,
						  "height": 1.65,
						  "grade": null,
						  "middle-school": "\"W3C\" MIDDLE SCHOOL",
						  "skills": [
							"JAVASCRIPT",
							"JAVA",
							"PYTHON",
							"LISP"
						  ]
						}
				如果还想精确控制如何序列化小明，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据
					var xiaoming = {
						name: '小明',
						age: 14,
						gender: true,
						height: 1.65,
						grade: null,
						'middle-school': '\"W3C\" Middle School',
						skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
						toJSON: function () {
							return { // 只输出name和age，并且改变了key：
								'Name': this.name,
								'Age': this.age
							};
						}
					};
					JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'
			反序列化
				拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象
					JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
					JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
					JSON.parse('true'); // true
					JSON.parse('123.45'); // 123.45
				JSON.parse()还可以接收一个函数，用来转换解析出的属性
					JSON.parse('{"name":"小明","age":14}', function (key, value) {
						// 把number * 2:
						if (key === 'name') {
							return value + '同学';
						}
						return value;
					}); // Object {name: '小明同学', age: 14}
			
	面向对象编程
		JavaScript的所有数据都可以看成对象，那是不是我们已经在使用面向对象编程了呢？
		当然不是。如果我们只使用Number、Array、string以及基本的{...}定义的对象，还无法发挥出面向对象编程的威力
			JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样
				Java或C#
					类：类是对象的类型模板，例如，定义Student类来表示学生，类本身是一种类型，Student表示学生类型，但不表示任何具体的某个学生；
					实例：实例是根据类创建的对象，例如，根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例，每个实例表示一个具体的学生，他们全都属于Student类型。
				JavaScript
					不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程
			有这么一个现成的对象
				var robot = {
					name: 'Robot',
					height: 1.6,
					run: function () {
						console.log(this.name + ' is running...');
					}
				};
			把它改名为Student，然后创建出xiaoming
				var Student = {
					name: 'Robot',
					height: 1.2,
					run: function () {
						console.log(this.name + ' is running...');
					}
				};

				var xiaoming = {
					name: '小明'
				};
			把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的
				xiaoming.__proto__ = Student;
				xiaoming.name; // '小明'
				xiaoming.run(); // 小明 is running...
			xiaoming有自己的name属性，但并没有定义run()方法。
			不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用
		JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例
		所谓继承关系不过是把一个对象的原型指向另一个对象而已	
			把xiaoming的原型指向其他对象
			var Bird = {
				fly: function () {
					console.log(this.name + ' is flying...');
				}
			};
			xiaoming.__proto__ = Bird;
			现在xiaoming已经无法run()了，他已经变成了一只鸟：
			xiaoming.fly(); // 小明 is flying...
		在JavaScrip代码运行时期，你可以把xiaoming从Student变成Bird，或者变成任何对象
		注意
			在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型
			并且，低版本的IE也无法使用__proto__
		Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有
			编写一个函数来创建xiaoming
				// 原型对象:
				var Student = {
					name: 'Robot',
					height: 1.2,
					run: function () {
						console.log(this.name + ' is running...');
					}
				};

				function createStudent(name) {
					// 基于Student原型创建一个新对象:
					var s = Object.create(Student);
					// 初始化新对象:
					s.name = name;
					return s;
				}

				var xiaoming = createStudent('小明');
				xiaoming.run(); // 小明 is running...
				xiaoming.__proto__ === Student; // true
		创建对象
			JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象
			当用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined
				创建一个Array对象
					var arr = [1, 2, 3];
				其原型链是：
					arr --> Array.prototype --> Object.prototype --> null
				Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法
			
				创建一个函数
					function foo() {
						return 0;
					}
				函数也是一个对象，它的原型链是：
					foo --> Function.prototype --> Object.prototype --> null
				由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法
			构造函数
				除了直接用{ ... }创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象
				它的用法是，先定义一个构造函数
					function Student(name) {
						this.name = name;
						this.hello = function () {
							alert('Hello, ' + this.name + '!');
						}
					}
				用关键字new来调用这个函数，并返回一个对象
					var xiaoming = new Student('小明');
					xiaoming.name; // '小明'
					xiaoming.hello(); // Hello, 小明!
				注意，如果不写new，这就是一个普通函数，它返回undefined
				但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;
				新创建的xiaoming的原型链是：
					xiaoming --> Student.prototype --> Object.prototype --> null
				如果又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：
					xiaoming K
					xiaohong -→ Student.prototype --> Object.prototype --> null
					xiaojun  J
				用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身
					xiaoming.constructor === Student.prototype.constructor; // true
					Student.prototype.constructor === Student; // true
					Object.getPrototypeOf(xiaoming) === Student.prototype; // true
					xiaoming instanceof Student; // true
				还有一个小问题，注意
					xiaoming.name; // '小明'
					xiaohong.name; // '小红'
					xiaoming.hello; // function: Student.hello()
					xiaohong.hello; // function: Student.hello()
					xiaoming.hello === xiaohong.hello; // false
					xiaoming和xiaohong各自的hello是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的
				如果通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数，这样可以节省很多内存
				只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型上就可以了
					function Student(name) {
						this.name = name;
					}

					Student.prototype.hello = function () {
						alert('Hello, ' + this.name + '!');
					};
				忘记写new怎么办？
					在strict模式下，this.name = name将报错，因为this绑定为undefined
					在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕
					调用构造函数千万不要忘记写new
					为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写
					还可以编写一个createStudent()函数，在内部封装所有的new操作
						function Student(props) {
							this.name = props.name || '匿名'; // 默认值为'匿名'
							this.grade = props.grade || 1; // 默认值为1
						}

						Student.prototype.hello = function () {
							alert('Hello, ' + this.name + '!');
						};

						function createStudent(props) {
							return new Student(props || {})
						}
					这个createStudent()函数有几个巨大的优点
						一是不需要new来调用
						二是参数非常灵活，可以不传，也可以这么传
							var xiaoming = createStudent({
								name: '小明'
							});

							xiaoming.grade; // 1
					利用构造函数定义Cat，并让所有的Cat对象有一个name属性，并共享一个方法say()，返回字符串'Hello, xxx!'
						'use strict';
						function Cat(name) {
							this.name = name;
						}

						Cat.prototype.say = function() {
							return "Hello, " + this.name + "!";
						}
						// 测试:
						var kitty = new Cat('Kitty');
						var doraemon = new Cat('哆啦A梦');
						if (kitty && kitty.name === 'Kitty' && kitty.say && typeof kitty.say === 'function' && kitty.say() === 'Hello, Kitty!' && kitty.say === doraemon.say) {
							alert('测试通过!');
						} else {
							alert('测试失败!');
						}
					
		原型继承
			基于Student扩展出PrimaryStudent
				1，先定义出PrimaryStudent
					function PrimaryStudent(props) {
						// 调用Student构造函数，绑定this变量:
						Student.call(this, props);
						this.grade = props.grade || 1;
					}
				但是，调用了Student构造函数不等于继承了Student
				PrimaryStudent创建的对象的原型链是：
					new PrimaryStudent() --> PrimaryStudent.prototype --> Object.prototype --> null
				必须想办法把原型链修改为：
					new PrimaryStudent() --> PrimaryStudent.prototype --> Student.prototype --> Object.prototype --> null
				2，借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype
					// 空函数F:
					function F() {
					}
					
					// 把F的原型指向Student.prototype:
					F.prototype = Student.prototype;

					// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
					PrimaryStudent.prototype = new F();

					// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
					PrimaryStudent.prototype.constructor = PrimaryStudent;
				3，继续在PrimaryStudent原型上定义方法
					// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
					PrimaryStudent.prototype.getGrade = function () {
						return this.grade;
					};
					
					// 创建xiaoming:
					var xiaoming = new PrimaryStudent({
						name: '小明',
						grade: 2
					});
					xiaoming.name; // '小明'
					xiaoming.grade; // 2
					
					// 验证原型:
					xiaoming.__proto__ === PrimaryStudent.prototype; // true
					xiaoming.__proto__.__proto__ === Student.prototype; // true

					// 验证继承关系:
					xiaoming instanceof PrimaryStudent; // true
					xiaoming instanceof Student; // true
				如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码
					function inherits(Child, Parent) {
						var F = function () {};
						F.prototype = Parent.prototype;
						Child.prototype = new F();
						Child.prototype.constructor = Child;
					}
					
					function Student(props) {
						this.name = props.name || 'Unnamed';
					}

					Student.prototype.hello = function () {
						alert('Hello, ' + this.name + '!');
					}

					function PrimaryStudent(props) {
						Student.call(this, props);
						this.grade = props.grade || 1;
					}

					// 实现原型继承链:
					inherits(PrimaryStudent, Student);

					// 绑定其他方法到PrimaryStudent原型:
					PrimaryStudent.prototype.getGrade = function () {
						return this.grade;
					};
			JavaScript的原型继承实现方式就是
				1，定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；
				2，借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；
				3，继续在新的构造函数的原型上定义新方法。
		class继承
			新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单
				回顾用函数实现Student的方法：
					function Student(name) {
						this.name = name;
					}

					Student.prototype.hello = function () {
						alert('Hello, ' + this.name + '!');
					}
				用新的class关键字来编写Student，可以这样写
					class Student {
						constructor(name) {
							this.name = name;
						}

						hello() {
							alert('Hello, ' + this.name + '!');
						}
					}
				比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字）
				这样就避免了Student.prototype.hello = function () {...}这样分散的代码
				最后，创建一个Student对象代码和前面章节完全一样：
					var xiaoming = new Student('小明');
					xiaoming.hello();
				class继承
					用class定义对象的另一个巨大的好处是继承更方便
					通过extends来实现
						class PrimaryStudent extends Student {
							constructor(name, grade) {
								super(name); // 记得用super调用父类的构造方法!
								this.grade = grade;
							}

							myGrade() {
								alert('I am at grade ' + this.grade);
							}
						}
					注意PrimaryStudent的定义也是class关键字实现的
					而extends则表示原型链对象来自Student
					子类的构造函数可能会与父类不太相同
						例如，PrimaryStudent需要name和grade两个参数
						并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化
						PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法
					利用class重新定义Cat，并让它从已有的Animal继承，然后新增一个方法say()，返回字符串'Hello, xxx!'
						'use strict';
						class Animal {
							constructor(name) {
								this.name = name;
							}
						}
						
						class Cat extends Animal {
							constructor(name) {
								super(name);
							}

							say() {
								return "Hello, " + this.name + "!";
							}
						}
						
						// 测试:
						var kitty = new Cat('Kitty');
						var doraemon = new Cat('哆啦A梦');
						if ((new Cat('x') instanceof Animal) && kitty && kitty.name === 'Kitty' && kitty.say && typeof kitty.say === 'function' && kitty.say() === 'Hello, Kitty!' && kitty.say === doraemon.say) {
							alert('测试通过!');
						} else {
							alert('测试失败!');
						}
		
			
	浏览器
		浏览器对象
			JavaScript可以获取浏览器提供的很多对象，并进行操作
			window
				window对象不仅充当全局作用域，而且表示浏览器窗口
				window对象有innerWidth和innerHeight属性，表示浏览器窗口的内部宽度和高度
				内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高
				IE<=8不支持
					'use strict';
					// 可以调整浏览器窗口大小试试:
					alert('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight);
				对应的，还有一个outerWidth和outerHeight属性，获取浏览器窗口的整个宽高
			navigator
				navigator对象表示浏览器的信息
				最常用的属性
					navigator.appName：浏览器名称；
					navigator.appVersion：浏览器版本；
					navigator.language：浏览器设置的语言；
					navigator.platform：操作系统类型；
					navigator.userAgent：浏览器设定的User-Agent字符串。
					
					'use strict';
					alert('appName = ' + navigator.appName + '\n' +
					  'appVersion = ' + navigator.appVersion + '\n' +
					  'language = ' + navigator.language + '\n' +
					  'platform = ' + navigator.platform + '\n' +
					  'userAgent = ' + navigator.userAgent);
				注意：navigator的信息可以很容易被用户修改，所以JavaScript读取的值不一定是正确的
					正确的判断浏览器版本的方法
						充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算
						var width = window.innerWidth || document.body.clientWidth;
			screen
				screen对象表示屏幕的信息
				常用的属性
					screen.width：屏幕宽度，以像素为单位；
					screen.height：屏幕高度，以像素为单位；
					screen.colorDepth：返回颜色位数，如8、16、24
					
					'use strict';
					alert('Screen size = ' + screen.width + ' x ' + screen.height);
			location
				location对象表示当前页面的URL信息
					例如，一个完整的URL
						http://www.example.com:8080/path/index.html?a=1&b=2#TOP
					可以用location.href获取
					要获得URL各个部分的值
						location.protocol; // 'http'
						location.host; // 'www.example.com'
						location.port; // '8080'
						location.pathname; // '/path/index.html'
						location.search; // '?a=1&b=2'
						location.hash; // 'TOP'
					要加载一个新页面，可以调用location.assign()
					要重新加载当前页面，调用location.reload()方法非常方便
						'use strict';
						if (confirm('重新加载当前页' + location.href + '?')) {
							location.reload();
						} else {
							location.assign('/discuss'); // 设置一个新的URL地址
						}
			document
				document对象表示当前页面
				由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点
				document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变
				要查找DOM树的某个节点，需要从document对象开始查找
				最常用的查找是根据ID和Tag Name
					先准备HTML数据：
						<dl id="drink-menu" style="border:solid 1px #ccc;padding:6px;">
							<dt>摩卡</dt>
							<dd>热摩卡咖啡</dd>
							<dt>酸奶</dt>
							<dd>北京老酸奶</dd>
							<dt>果汁</dt>
							<dd>鲜榨苹果汁</dd>
						</dl>
					用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点
						'use strict';
						var i, s, menu, drinks;

						menu = document.getElementById('drink-menu');
						menu.tagName; // 'DL'

						drinks = document.getElementsByTagName('dt');
						s = '提供的饮料有:';
						for (i=0; i<drinks.length; i++) {
							s = s + drinks[i].innerHTML + ',';
						}
						alert(s);
					document对象还有一个cookie属性，可以获取当前页面的Cookie
						Cookie是由服务器发送的key-value标示符
						因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分
						当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)...
						此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户
						Cookie还可以存储网站的一些设置，例如，页面显示的语言等等
						JavaScript可以通过document.cookie读取到当前页面的Cookie
							document.cookie; // 'v=123; remember=true; prefer=zh'
						由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患
						因为在HTML页面中引入第三方的JavaScript代码是允许的
							<!-- 当前页面在wwwexample.com -->
							<html>
								<head>
									<script src="http://www.foo.com/jquery.js"></script>
								</head>
								...
							</html>
						如果引入的第三方的JavaScript中存在恶意代码，则www.foo.com网站将直接获取到www.example.com网站的用户登录信息
						为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取
						这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持
						为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly
			history
				history对象保存了浏览器的历史记录
				JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮
				任何情况，你都不应该使用history这个对象了
		操作DOM
			由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM
			DOM是一个树形结构
				更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；
				遍历：遍历该DOM节点下的子节点，以便进行进一步操作；
				添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；
				删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。
			在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点
			最常用的方法是document.getElementById()和document.getElementsByTagName()，以及CSS选择器document.getElementsByClassName()
			由于ID在HTML文档中是唯一的，所以document.getElementById()可以直接定位唯一的一个DOM节点。
			document.getElementsByTagName()和document.getElementsByClassName()总是返回一组DOM节点。
			要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围
				// 返回ID为'test'的节点：
				var test = document.getElementById('test');

				// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：
				var trs = document.getElementById('test-table').getElementsByTagName('tr');

				// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：
				var reds = document.getElementById('test-div').getElementsByClassName('red');

				// 获取节点test下的所有直属子节点:
				var cs = test.children;

				// 获取节点test下第一个、最后一个子节点：
				var first = test.firstElementChild;
				var last = test.lastElementChild;
			第二种方法是使用querySelector()和querySelectorAll()，需要了解selector语法，然后使用条件来获取节点，更加方便
				// 通过querySelector获取ID为q1的节点：
				var q1 = document.querySelector('#q1');

				// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
				var ps = q1.querySelectorAll('div.highlighted > p');
			注意：低版本的IE<8不支持querySelector和querySelectorAll。IE8仅有限支持
			严格地讲，我们这里的DOM节点是指Element
			但是DOM节点实际上是Node，在HTML中，Node包括Element、Comment、CDATA_SECTION等很多种，以及根节点Document类型
			但是，绝大多数时候我们只关心Element，也就是实际控制页面结构的Node，其他类型的Node忽略即可。根节点Document已经自动绑定为全局变量document
			
			更新DOM
				可以直接修改节点的文本，方法有两种
				一种是修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树
					// 获取<p id="p-id">...</p>
					var p = document.getElementById('p-id');
					// 设置文本为abc:
					p.innerHTML = 'ABC'; // <p id="p-id">ABC</p>
					// 设置HTML:
					p.innerHTML = 'ABC <span style="color:red">RED</span> XYZ';
					// <p>...</p>的内部结构已修改
				用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击
				第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签
					// 获取<p id="p-id">...</p>
					var p = document.getElementById('p-id');
					// 设置文本:
					p.innerText = '<script>alert("Hi")</script>';
					// HTML被自动编码，无法设置一个<script>节点:
					// <p id="p-id">&lt;script&gt;alert("Hi")&lt;/script&gt;</p>
				两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本
				另外注意IE<9不支持textContent。
				修改CSS也是经常需要的操作。DOM节点的style属性对应所有的CSS，可以直接获取或设置
				因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize
					// 获取<p id="p-id">...</p>
					var p = document.getElementById('p-id');
					// 设置CSS:
					p.style.color = '#ff0000';
					p.style.fontSize = '20px';
					p.style.paddingTop = '2em';
			添加DOM
				当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？
					如果这个DOM节点是空的，例如，<div></div>，那么，直接使用innerHTML = '<span>child</span>'就可以修改DOM节点的内容，相当于“插入”了新的DOM节点
					如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点
					有两个办法可以插入新的节点
						一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点
								<!-- HTML结构 -->
								<p id="js">JavaScript</p>
								<div id="list">
									<p id="java">Java</p>
									<p id="python">Python</p>
									<p id="scheme">Scheme</p>
								</div>
							把<p id="js">JavaScript</p>添加到<div id="list">的最后一项
								var
									js = document.getElementById('js'),
									list = document.getElementById('list');
								list.appendChild(js);
							现在，HTML结构变成了这样：
								<!-- HTML结构 -->
								<div id="list">
									<p id="java">Java</p>
									<p id="python">Python</p>
									<p id="scheme">Scheme</p>
									<p id="js">JavaScript</p>
								</div>
							因为我们插入的js节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。
						更多的时候我们会从零创建一个新的节点，然后插入到指定位置
								var
									list = document.getElementById('list'),
									haskell = document.createElement('p');
								haskell.id = 'haskell';
								haskell.innerText = 'Haskell';
								list.appendChild(haskell);
							这样我们就动态添加了一个新的节点
								<!-- HTML结构 -->
								<div id="list">
									<p id="java">Java</p>
									<p id="python">Python</p>
									<p id="scheme">Scheme</p>
									<p id="haskell">Haskell</p>
								</div>
							动态创建一个节点然后添加到DOM树中，可以实现很多功能
								举个例子，下面的代码动态创建了一个<style>节点，然后把它添加到<head>节点的末尾，这样就动态地给文档添加了新的CSS定义
									var d = document.createElement('style');
									d.setAttribute('type', 'text/css');
									d.innerHTML = 'p { color: red }';
									document.getElementsByTagName('head')[0].appendChild(d);
						如果我们要把子节点插入到指定的位置怎么办？
							可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前
								以上面的HTML为例，假定我们要把Haskell插入到Python之前
									<!-- HTML结构 -->
									<div id="list">
										<p id="java">Java</p>
										<p id="python">Python</p>
										<p id="scheme">Scheme</p>
									</div>
								可以这么写：
									var
										list = document.getElementById('list'),
										ref = document.getElementById('python'),
										haskell = document.createElement('p');
									haskell.id = 'haskell';
									haskell.innerText = 'Haskell';
									list.insertBefore(haskell, ref);
								新的HTML结构如下：
									<!-- HTML结构 -->
									<div id="list">
										<p id="java">Java</p>
										<p id="haskell">Haskell</p>
										<p id="python">Python</p>
										<p id="scheme">Scheme</p>
									</div>
							可见，使用insertBefore重点是要拿到一个“参考子节点”的引用
							很多时候，需要循环一个父节点的所有子节点，可以通过迭代children属性实现
								var
									i, c,
									list = document.getElementById('list');
								for (i = 0; i < list.children.length; i++) {
									c = list.children[i]; // 拿到第i个子节点
								}
							练习
								对于一个已有的HTML结构
									<!-- HTML结构 -->
									<ol id="test-list">
										<li class="lang">Scheme</li>
										<li class="lang">JavaScript</li>
										<li class="lang">Python</li>
										<li class="lang">Ruby</li>
										<li class="lang">Haskell</li>
									</ol>
								按字符串顺序重新排序DOM节点
									'use strict';
									// sort list:
									var tmp = [], 
										ol = document.getElementById('test-list');
									for (var i of ol.children) {
										tmp.push(i);
									}
									tmp.sort((x, y) => {return x.innerText > y.innerText;});
									for (var j of tmp) {
										ol.appendChild(j);
									}
			删除DOM
				要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉
					// 拿到待删除节点:
					var self = document.getElementById('to-be-removed');
					// 拿到父节点:
					var parent = self.parentElement;
					// 删除:
					var removed = parent.removeChild(self);
					removed === self; // true
				注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置
				当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新
					对于如下HTML结构：
						<div id="parent">
							<p>First</p>
							<p>Second</p>
						</div>
					当我们用如下代码删除子节点时
						var parent = document.getElementById('parent');
						parent.removeChild(parent.children[0]);
						parent.removeChild(parent.children[1]); // <-- 浏览器报错
					浏览器报错：parent.children[1]不是一个有效的节点
						原因就在于，当<p>First</p>节点被删除后，parent.children的节点数量已经从2变为了1，索引[1]已经不存在了
					因此，删除多个节点时，要注意children属性时刻都在变化
					练习
							<!-- HTML结构 -->
							<ul id="test-list">
								<li>JavaScript</li>
								<li>Swift</li>
								<li>HTML</li>
								<li>ANSI C</li>
								<li>CSS</li>
								<li>DirectX</li>
							</ul>
						把与Web开发技术不相关的节点删掉
							var par =  document.getElementById('test-list');
							var list = par.children;
							for ( var i = list.length - 1 ;  i >= 0 ; i-- ) {
								if( list[i].innerText === 'Swift' || list[i].innerText === 'ANSI C' || list[i].innerText === 'DirectX') {
									par.removeChild(list[i]);
								}
							}
							
							// 测试:
							;(function () {
								var
									arr, i,
									t = document.getElementById('test-list');
								if (t && t.children && t.children.length === 3) {
									arr = [];
									for (i = 0; i < t.children.length; i ++) {
										arr.push(t.children[i].innerText);
									}
									if (arr.toString() === ['JavaScript', 'HTML', 'CSS'].toString()) {
										alert('测试通过!');
									}
									else {
										alert('测试失败: ' + arr.toString());
									}
								}
								else {
									alert('测试失败!');
								}
							})();
		操作表单
			用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树
			不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容
			HTML表单的输入控件主要有以下几种
				文本框，对应的<input type="text">，用于输入文本；
				口令框，对应的<input type="password">，用于输入口令；
				单选框，对应的<input type="radio">，用于选择一项；
				复选框，对应的<input type="checkbox">，用于选择多项；
				下拉框，对应的<select>，用于选择一项；
				隐藏文本，对应的<input type="hidden">，用户不可见，但表单提交时会把隐藏文本发送到服务器。
			获取值
				如果获得了一个<input>节点的引用，就可以直接调用value获得对应的用户输入值
					// <input type="text" id="email">
					var input = document.getElementById('email');
					input.value; // '用户输入的值'
				这种方式可以应用于text、password、hidden以及select
				但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断
					// <label><input type="radio" name="weekday" id="monday" value="1"> Monday</label>
					// <label><input type="radio" name="weekday" id="tuesday" value="2"> Tuesday</label>
					var mon = document.getElementById('monday');
					var tue = document.getElementById('tuesday');
					mon.value; // '1'
					tue.value; // '2'
					mon.checked; // true或者false
					tue.checked; // true或者false
			设置值
				设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以
					// <input type="text" id="email">
					var input = document.getElementById('email');
					input.value = 'test@example.com'; // 文本框的内容已更新
				对于单选框和复选框，设置checked为true或false即可
			HTML5控件
				HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用<input>标签
					<input type="date" value="2015-07-01">
					<input type="datetime-local" value="2015-07-01T02:03:04">
					<input type="color" value="#ff0000">
				不支持HTML5的浏览器无法识别新的控件，会把它们当做type="text"来显示
				支持HTML5的浏览器将获得格式化的字符串
					如，type="date"类型的input的value将保证是一个有效的YYYY-MM-DD格式的日期，或者空字符串
			提交表单
				JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）
					方式一是通过<form>元素的submit()方法提交一个表单
						如，响应一个<button>的click事件，在JavaScript代码中提交表单
							<!-- HTML -->
							<form id="test-form">
								<input type="text" name="test">
								<button type="button" onclick="doSubmitForm()">Submit</button>
							</form>

							<script>
							function doSubmitForm() {
								var form = document.getElementById('test-form');
								// 可以在此修改form的input...
								// 提交form:
								form.submit();
							}
							</script>
						这种方式的缺点是扰乱了浏览器对form的正常提交
						浏览器默认点击<button type="submit">时提交表单，或者用户在最后一个输入框按回车键
					第二种方式是响应<form>本身的onsubmit事件，在提交form时作修改
						<!-- HTML -->
						<form id="test-form" onsubmit="return checkForm()">
							<input type="text" name="test">
							<button type="submit">Submit</button>
						</form>

						<script>
						function checkForm() {
							var form = document.getElementById('test-form');
							// 可以在此修改form的input...
							// 继续下一步:
							return true;
						}
						</script>
						
						注意要return true来告诉浏览器继续提交
						如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form
						
						在检查和修改<input>时，要充分利用<input type="hidden">来传递数据
							例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5
								普通JavaScript开发人员会直接修改<input>
									<!-- HTML -->
									<form id="login-form" method="post" onsubmit="return checkForm()">
										<input type="text" id="username" name="username">
										<input type="password" id="password" name="password">
										<button type="submit">Submit</button>
									</form>

									<script>
									function checkForm() {
										var pwd = document.getElementById('password');
										// 把用户输入的明文变为MD5:
										pwd.value = toMD5(pwd.value);
										// 继续下一步:
										return true;
									}
									</script>
								用户输入了口令提交时，口令框的显示会突然从几个*变成32个*（因为MD5有32个字符）
								
								要想不改变用户的输入，可以利用<input type="hidden">实现
									<!-- HTML -->
									<form id="login-form" method="post" onsubmit="return checkForm()">
										<input type="text" id="username" name="username">
										<input type="password" id="input-password">
										<input type="hidden" id="md5-password" name="password">
										<button type="submit">Submit</button>
									</form>

									<script>
									function checkForm() {
										var input_pwd = document.getElementById('input-password');
										var md5_pwd = document.getElementById('md5-password');
										// 把用户输入的明文变为MD5:
										md5_pwd.value = toMD5(input_pwd.value);
										// 继续下一步:
										return true;
									}
									</script>
								注意到id为md5-password的<input>标记了name="password"，而用户输入的id为input-password的<input>没有name属性。
								没有name属性的<input>的数据不会被提交
					练习
						利用JavaScript检查用户注册信息是否正确，在以下情况不满足时报错并阻止提交表单
							用户名必须是3-10位英文字母或数字；
							口令必须是6-20位；
							两次输入口令必须一致。
							
							<!-- HTML结构 -->
							<form id="test-register" action="#" target="_blank" onsubmit="return checkRegisterForm()">
								<p id="test-error" style="color:red"></p>
								<p>
									用户名: <input type="text" id="username" name="username">
								</p>
								<p>
									口令: <input type="password" id="password" name="password">
								</p>
								<p>
									重复口令: <input type="password" id="password-2">
								</p>
								<p>
									<button type="submit">提交</button> <button type="reset">重置</button>
								</p>
							</form>
							
							'use strict';
							var checkRegisterForm = function () {
							// TODO:
							var
								reUserName = /\w{3,10}/,
								strUserName = document.getElementById('username').value,
								rePwd1 = /.{6,20}/,
								strPwd1 = document.getElementById('password').value,
								strPwd2 = document.getElementById('password-2').value;
							if(reUserName.test(strUserName)){
								if(rePwd1.test(strPwd1)){
									if(strPwd1 === strPwd2){
										alert("注册成功!");
										return true;
									} else {
										alert("两次口令必须一致!");
										return false;
									}
								} else {
									alert("口令必须是6到20位");
									return false;
								}
							} else {
								alert("用户名必须是3到10位的数字或字母");
								return false;
							}
						}
						
						// 测试:
						;(function () {
							window.testFormHandler = checkRegisterForm;
							var form = document.getElementById('test-register');
							if (form.dispatchEvent) {
								var event = new Event('submit', {
									bubbles: true,
									cancelable: true
								  });
								form.dispatchEvent(event);
							} else {
								form.fireEvent('onsubmit');
							}
						})();
		操作文件
			在HTML表单中，可以上传文件的唯一控件就是<input type="file">
			注意：当一个表单包含<input type="file">时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据
			出于安全考虑，浏览器只允许用户点击<input type="file">来选择本地文件，用JavaScript对<input type="file">的value赋值是没有任何效果的。
			当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径
			通常，上传的文件都由后台服务器处理
			JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件
				var f = document.getElementById('test-file-upload');
				var filename = f.value; // 'C:\fakepath\test.png'
				if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) {
					alert('Can only upload image file.');
					return false;
				}
			File API
				由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现
				随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息
				HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件
				例子
					读取用户选取的图片文件，并在一个<div>中预览图像
						var
							fileInput = document.getElementById('test-image-file'),
							info = document.getElementById('test-file-info'),
							preview = document.getElementById('test-image-preview');
						// 监听change事件:
						fileInput.addEventListener('change', function () {
							// 清除背景图片:
							preview.style.backgroundImage = '';
							// 检查文件是否选择:
							if (!fileInput.value) {
								info.innerHTML = '没有选择文件';
								return;
							}
							// 获取File引用:
							var file = fileInput.files[0];
							// 获取File信息:
							info.innerHTML = '文件: ' + file.name + '<br>' +
											 '大小: ' + file.size + '<br>' +
											 '修改: ' + file.lastModifiedDate;
							if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') {
								alert('不是有效的图片文件!');
								return;
							}
							// 读取文件:
							var reader = new FileReader();
							reader.onload = function(e) {
								var
									data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            
								preview.style.backgroundImage = 'url(' + data + ')';
							};
							// 以DataURL的形式读取文件:
							reader.readAsDataURL(file);
						});
					上面的代码演示了如何通过HTML5的File API读取文件内容
					以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像
					如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容
				回调
					上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式
					在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行
					也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行
					单线程模式执行的JavaScript，如何处理多任务？
						在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码reader.readAsDataURL(file);
						会发起一个异步操作来读取文件内容
						因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：
							reader.onload = function(e) {
								// 当文件读取完成后，自动调用此函数:
							};
						当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数
						执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容
						
		AJAX
			AJAX不是JavaScript的规范，意思就是用JavaScript执行异步网络请求
			如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了
			如果不幸由于网络太慢或者其他原因，就会得到一个404页面
			这就是Web的运作原理：一次HTTP请求对应一个页面
			如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新
			用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应
			在现代浏览器上写AJAX主要依靠XMLHttpRequest对象
				'use strict';
				function success(text) {
					var textarea = document.getElementById('test-response-text');
					textarea.value = text;
				}

				function fail(code) {
					var textarea = document.getElementById('test-response-text');
					textarea.value = 'Error code: ' + code;
				}

				var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

				request.onreadystatechange = function () { // 状态发生变化时，函数被回调
					if (request.readyState === 4) { // 成功完成
						// 判断响应结果:
						if (request.status === 200) {
							// 成功，通过responseText拿到响应的文本:
							return success(request.responseText);
						} else {
							// 失败，根据响应码判断失败原因:
							return fail(request.status);
						}
					} else {
						// HTTP请求还在继续...
					}
				}

				// 发送请求:
				request.open('GET', '/api/categories');
				request.send();

				alert('请求已发送，请等待响应...');
			对于低版本的IE，需要换一个ActiveXObject对象
				'use strict';
				function success(text) {
					var textarea = document.getElementById('test-ie-response-text');
					textarea.value = text;
				}

				function fail(code) {
					var textarea = document.getElementById('test-ie-response-text');
					textarea.value = 'Error code: ' + code;
				}

				var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象

				request.onreadystatechange = function () { // 状态发生变化时，函数被回调
					if (request.readyState === 4) { // 成功完成
						// 判断响应结果:
						if (request.status === 200) {
							// 成功，通过responseText拿到响应的文本:
							return success(request.responseText);
						} else {
							// 失败，根据响应码判断失败原因:
							return fail(request.status);
						}
					} else {
						// HTTP请求还在继续...
					}
				}

				// 发送请求:
				request.open('GET', '/api/categories');
				request.send();

				alert('请求已发送，请等待响应...');
			如果你想把标准写法和IE写法混在一起，可以这么写
				var request;
				if (window.XMLHttpRequest) {
					request = new XMLHttpRequest();
				} else {
					request = new ActiveXObject('Microsoft.XMLHTTP');
				}
				通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest
				注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性
					一是因为这个字符串本身可以伪造
					二是通过IE版本判断JavaScript特性将非常复杂
					
			当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数
			在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。
			XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写
			注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态
			最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去
			安全限制
				上面代码的URL使用的是相对路径。如果你把它改为'http://www.sina.com.cn/'，再运行，肯定报错
				这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致
				完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）
				那用JavaScript请求外域（就是其他网站）的URL了呢？大概有这么几种方法
					一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了
					二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：
						'/proxy?url=http://www.sina.com.cn'
						代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发
					第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript
						这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源
							<html>
							<head>
								<script src="http://example.com/abc.js"></script>
								...
							</head>
							<body>
							...
							</body>
							</html>
						JSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下
							foo('data');
						这样一来，我们如果在页面中先准备好foo()函数，然后给页面动态加一个<script>节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了
							以163的股票查询URL为例
								对于URL：http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，你将得到如下返回
									refreshPrice({"0000001":{"code": "0000001", ... });
								因此我们需要首先在页面中准备好回调函数
									function refreshPrice(data) {
										var p = document.getElementById('test-jsonp');
										p.innerHTML = '当前价格：' +
											data['0000001'].name +': ' + 
											data['0000001'].price + '；' +
											data['1399001'].name + ': ' +
											data['1399001'].price;
									}
									
									<div>
										<p id="test-jsonp">当前价格：</p>
										<p><button type="button" onclick="getPrice()">刷新</button></p>
									</div>
									
									最后用getPrice()函数触发：
										function getPrice() {
											var
												js = document.createElement('script'),
												head = document.getElementsByTagName('head')[0];
											js.src = 'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice';
											head.appendChild(js);
										}
									就完成了跨域加载数据
			CORS
				如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS
				CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源
				Origin表示本域，也就是浏览器当前页面的域
				当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域
					如果是，则此次跨域请求成功，
					如果不是，则请求失败，JavaScript将无法获取到响应的任何数据
					假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功
				可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中
				上面这种跨域请求，称之为“简单请求”
					简单请求包括GET、HEAD和POST（POST的Content-Type类型）
					仅限application/x-www-form-urlencoded、multipart/form-data和text/plain），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求
				最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS
					例如，当你引用了某个第三方CDN上的字体文件时：
						/* CSS */
						@font-face {
						  font-family: 'FontAwesome';
						  src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype');
						}
					如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。
				对于PUT、DELETE以及其他类型如application/json的POST请求
					在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受
						OPTIONS /path/to/resource HTTP/1.1
						Host: bar.com
						Origin: http://my.com
						Access-Control-Request-Method: POST
					服务器必须响应并明确指出允许的Method：
						HTTP/1.1 200 OK
						Access-Control-Allow-Origin: http://my.com
						Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS
						Access-Control-Max-Age: 86400
					浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。
					由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求
		Promise
			在JavaScript的世界中，所有代码都是单线程执行的，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行
			一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败
				function test(resolve, reject) {
					var timeOut = Math.random() * 2;
					log('set timeout to: ' + timeOut + ' seconds.');
					setTimeout(function () {
						if (timeOut < 1) {
							log('call resolve()...');
							resolve('200 OK');
						}
						else {
							log('call reject()...');
							reject('timeout in ' + timeOut + ' seconds.');
						}
					}, timeOut * 1000);
				}
				
				这个test()函数有两个参数，这两个参数都是函数
				如果执行成功，我们将调用resolve('200 OK')，如果执行失败，我们将调用reject('timeout in ' + timeOut + ' seconds.')
				test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果
				有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果
					var p1 = new Promise(test);
					var p2 = p1.then(function (result) {
						console.log('成功：' + result);
					});
					var p3 = p2.catch(function (reason) {
						console.log('失败：' + reason);
					});
				变量p1是一个Promise对象，它负责执行test函数
				由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象
					// 如果成功，执行这个函数：
					p1.then(function (result) {
						console.log('成功：' + result);
					});
				当test函数执行失败时，我们告诉Promise对象：
					p2.catch(function (reason) {
						console.log('失败：' + reason);
					});
				Promise对象可以串联起来，所以上述代码可以简化为：
					new Promise(test).then(function (result) {
						console.log('成功：' + result);
					}).catch(function (reason) {
						console.log('失败：' + reason);
					});
			有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数
				job1.then(job2).then(job3).catch(handleError);
				其中，job1、job2和job3都是Promise对象
			把上一节的AJAX异步执行函数转换为Promise对象
					'use strict';
					function success(text) {
						var textarea = document.getElementById('test-response-text');
						textarea.value = text;
					}

					function fail(code) {
						var textarea = document.getElementById('test-response-text');
						textarea.value = 'Error code: ' + code;
					}

					var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

					request.onreadystatechange = function () { // 状态发生变化时，函数被回调
						if (request.readyState === 4) { // 成功完成
							// 判断响应结果:
							if (request.status === 200) {
								// 成功，通过responseText拿到响应的文本:
								return success(request.responseText);
							} else {
								// 失败，根据响应码判断失败原因:
								return fail(request.status);
							}
						} else {
							// HTTP请求还在继续...
						}
					}

					// 发送请求:
					request.open('GET', '/api/categories');
					request.send();

					alert('请求已发送，请等待响应...');
				改为：	
					'use strict';
					// ajax函数将返回Promise对象:
					function ajax(method, url, data) {
						var request = new XMLHttpRequest();
						return new Promise(function (resolve, reject) {
							request.onreadystatechange = function () {
								if (request.readyState === 4) {
									if (request.status === 200) {
										resolve(request.responseText);
									} else {
										reject(request.status);
									}
								}
							};
							request.open(method, url);
							request.send(data);
						});
					}

					var log = document.getElementById('test-promise-ajax-result');
					var p = ajax('GET', '/api/categories');
					p.then(function (text) { // 如果AJAX成功，获得响应内容
						log.innerText = text;
					}).catch(function (status) { // 如果AJAX失败，获得响应代码
						log.innerText = 'ERROR: ' + status;
					});
			Promise还可以并行执行异步任务
				试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的
				用Promise.all()实现如下
					var p1 = new Promise(function (resolve, reject) {
						setTimeout(resolve, 500, 'P1');
					});
					var p2 = new Promise(function (resolve, reject) {
						setTimeout(resolve, 600, 'P2');
					});
					// 同时执行p1和p2，并在它们都完成后执行then:
					Promise.all([p1, p2]).then(function (results) {
						console.log(results); // 获得一个Array: ['P1', 'P2']
					});
				有些时候，多个异步任务是为了容错
				比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可
				这种情况下，用Promise.race()实现
					var p1 = new Promise(function (resolve, reject) {
						setTimeout(resolve, 500, 'P1');
					});
					var p2 = new Promise(function (resolve, reject) {
						setTimeout(resolve, 600, 'P2');
					});
					Promise.race([p1, p2]).then(function (result) {
						console.log(result); // 'P1'
					});
					由于p1执行较快，Promise的then()将获得结果'P1'。p2仍在继续执行，但执行结果将被丢弃
		Canvas
			Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等
			没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。
			有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制
			一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制
				<canvas id="test-canvas" width="300" height="200"></canvas>
			由于浏览器对HTML5标准支持不一致，所以，通常在<canvas>内部添加一些说明性HTML代码
				如果浏览器支持Canvas，它将忽略<canvas>内部的HTML
				如果浏览器不支持Canvas，它将显示<canvas>内部的HTML
					<canvas id="test-stock" width="300" height="200">
						<p>Current Price: 25.51</p>
					</canvas>
			在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas
				<!-- HTML代码 -->
				<canvas id="test-canvas" width="200" heigth="100">
					<p>你的浏览器不支持Canvas</p>
				</canvas>
				
				'use strict';
				var canvas = document.getElementById('test-canvas');
				if (canvas.getContext) {
					alert('你的浏览器支持Canvas!');
				} else {
					alert('你的浏览器不支持Canvas!');
				}
			getContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成
				var ctx = canvas.getContext('2d');
			如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形
				gl = canvas.getContext("webgl");
			绘制形状
				我们可以在Canvas上绘制各种形状。
				在绘制前，我们需要先了解一下Canvas的坐标系统
					(0,0)------------------>x
						|
						|
						|
						|
						V
						y
				Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数
				CanvasRenderingContext2D对象有若干方法来绘制图形
					'use strict';
					var
						canvas = document.getElementById('test-shape-canvas'),
						ctx = canvas.getContext('2d');
						ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
						ctx.fillStyle = '#dddddd'; // 设置颜色
						ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
						// 利用Path绘制复杂路径:
						var path=new Path2D();
						path.arc(75, 75, 50, 0, Math.PI*2, true);
						path.moveTo(110,75);
						path.arc(75, 75, 35, 0, Math.PI, false);
						path.moveTo(65, 65);
						path.arc(60, 65, 5, 0, Math.PI*2, true);
						path.moveTo(95, 65);
						path.arc(90, 65, 5, 0, Math.PI*2, true);
						ctx.strokeStyle = '#0000ff';
						ctx.stroke(path);
			绘制文本
				绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致
					'use strict';
					var
						canvas = document.getElementById('test-text-canvas'),
						ctx = canvas.getContext('2d');
					ctx.clearRect(0, 0, canvas.width, canvas.height);
					ctx.shadowOffsetX = 2;
					ctx.shadowOffsetY = 2;
					ctx.shadowBlur = 2;
					ctx.shadowColor = '#666666';
					ctx.font = '24px Arial';
					ctx.fillStyle = '#333333';
					ctx.fillText('带阴影的文字', 20, 40);
			Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作
			如果要实现非常复杂的操作，考虑以下优化方案：
				通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；
				尽量使用整数坐标而不是浮点数；
				可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；
				背景图片如果不变可以直接用<img>标签并放到最底层。
			练习
				请根据从163获取的JSON数据绘制最近30个交易日的K线图，数据已处理为包含一组对象的数组
					'use strict';
					window.loadStockData = function (r) {
						var
							NUMS = 30,
							data = r.data;
						if (data.length > NUMS) {
							data = data.slice(data.length - NUMS);
						}
						data = data.map(function (x) {
							return {
								date: x[0],
								open: x[1],
								close: x[2],
								high: x[3],
								low: x[4],
								vol: x[5],
								change: x[6]
							};
						});
						window.drawStock(data);
					}
					
					window.drawStock = function (data) {
						canvas = document.getElementById('stock-canvas'),
						width = canvas.width,
						height = canvas.height,
						ctx = canvas.getContext('2d');
					console.log(JSON.stringify(data[0])); // {"date":"20150602","open":4844.7,"close":4910.53,"high":4911.57,"low":4797.55,"vol":62374809900,"change":1.69}
					ctx.clearRect(0, 0, width, height);
					ctx.fillText('Test Canvas', 10, 10);
					
					ctx.fillStyle="#000000"; //设置画笔颜色为黑色
					ctx.fillRect(0,0,width,height); //填充幕布

					var candle_width=width/data.length; //定义蜡烛宽度
					var ratio=0.5; //蜡烛缩放比例
					var baseline=height/2;//定义基线

					for(let i=0;i<data.length;i++){
					var temp=data[i];
					var up=(temp.close-temp.open>=0)?true:false; //今日上涨还是下跌
					var candle_x=candle_width*i; //蜡烛的x坐标
					var candle_height=Math.abs(temp.close-temp.open)*ratio; //蜡烛的高度
					var candle_y=0; //蜡烛的y坐标

					if (up){
						ctx.fillStyle="#ff0000"; //设置填充颜色
						ctx.strokeStyle="#ff0000";//设置线条颜色
						candle_y=baseline-candle_height; //蜡烛的y坐标
						ctx.fillRect(candle_x,candle_y,candle_width,candle_height); //画蜡烛的方块部分
						var stick_high_height=(temp.high-temp.close)*ratio; //上方火苗的高度
						var stick_low_height=(temp.open-temp.low)*ratio; //下方火苗的高度
						ctx.beginPath();
						ctx.moveTo(candle_x+candle_width/2,candle_y);
						ctx.lineTo(candle_x+candle_width/2,candle_y-stick_high_height);
						ctx.stroke(); //画上方火苗

						ctx.beginPath();
						ctx.moveTo(candle_x+candle_width/2,candle_y+candle_height);
						ctx.lineTo(candle_x+candle_width/2,candle_y+candle_height+stick_low_height);
						ctx.stroke(); //画下方火苗
						baseline=candle_y; //重新设置基线
					}else{
						ctx.fillStyle="#00ff00";
						ctx.strokeStyle="#00ff00";
						candle_y=baseline;
						ctx.fillRect(candle_x,candle_y,candle_width,candle_height);
						ctx.beginPath();
						ctx.moveTo(candle_x+candle_width/2,candle_y);
						ctx.lineTo(candle_x+candle_width/2,candle_y-stick_high_height);
						ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(candle_x+candle_width/2,candle_y+candle_height);
						ctx.lineTo(candle_x+candle_width/2,candle_y+candle_height+stick_low_height);
						ctx.stroke();
						baseline=candle_y+candle_height;
					}
					}
					};

					// 加载最近30个交易日的K线图数据:
					var js = document.createElement('script');
					js.src = 'http://img1.money.126.net/data/hs/kline/day/history/2015/0000001.json?callback=loadStockData&t=' + Date.now();
					document.getElementsByTagName('head')[0].appendChild(js);

	jQuery
		实际上，jQuery能帮我们干这些事情：
			消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；
			简洁的操作DOM的方法：写$('#test')肯定比document.getElementById('test')来得简洁；
			轻松实现动画、修改CSS等各种操作。
		jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作
		jQuery版本
			目前jQuery有1.x和2.x两个主要版本
			区别在于2.x移除了对古老的IE 6、7、8的支持，因此2.x的代码更精简
			jQuery只是一个jquery-xxx.js文件，但你会看到有compressed（已压缩）和uncompressed（未压缩）两种版本
			如果你想深入研究jQuery源码，那就用uncompressed版本
		使用jQuery
			使用jQuery只需要在页面的<head>引入jQuery文件即可
				<html>
				<head>
					<script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
					...
				</head>
				<body>
					...
				</body>
				</html>
			好消息是，由于网站本身已经引用了jQuery，所以你可以直接使用
				'use strict';
				alert('jQuery版本：' + $.fn.jquery);
		$符号
			$是著名的jQuery符号
			实际上，jQuery把所有功能全部封装在一个全局变量jQuery中
			而$也是一个合法的变量名，它是变量jQuery的别名
				window.jQuery; // jQuery(selector, context)
				window.$; // jQuery(selector, context)
				$ === jQuery; // true
				typeof($); // 'function'
			$本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性
			注意，你看到的$函数名可能不是jQuery(selector, context)，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码$函数可能变成a(b, c)
			绝大多数时候，我们都直接用$
			但是，如果$这个变量不幸地被占用了，而且还不能改，就只能使用jQuery这个变量
				$; // jQuery(selector, context)
				jQuery.noConflict();
				$; // undefined
				jQuery; // jQuery(selector, context)
		选择器
			选择器是jQuery的核心。一个选择器写出来类似$('#dom-id')
			为什么jQuery要发明选择器？
				DOM操作中我们经常使用的代码太繁琐了
				并且，在层级关系中，例如，查找<table class="green">里面的所有<tr>，一层循环实际上是错的，因为<table>的标准写法是
					<table>
						<tbody>
							<tr>...</tr>
							<tr>...</tr>
						</tbody>
					</table>
				很多时候，需要递归查找所有子节点
			jQuery的选择器就是帮助我们快速定位到一个或多个DOM节点
			按ID查找
				如果某个DOM节点有id属性，利用jQuery查找如下
					// 查找<div id="abc">:
					var div = $('#abc');
					注意，#abc以#开头。返回的对象是jQuery对象
				什么是jQuery对象？
					jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象
						以上面的查找为例
							如果id为abc的<div>存在，返回的jQuery对象如下
								[<div id="abc">...</div>]
							如果id为abc的<div>不存在，返回的jQuery对象如下
								[]
						总之jQuery的选择器不会返回undefined或者null
					jQuery对象和DOM对象之间可以互相转化：
						var div = $('#abc'); // jQuery对象
						var divDom = div.get(0); // 假设存在div，获取第1个DOM元素
						var another = $(divDom); // 重新把DOM包装为jQuery对象
			按tag查找
				只需要写上tag名称就可以
					var ps = $('p'); // 返回所有<p>节点
					ps.length; // 数一数页面有多少个<p>节点
			按class查找
				在class名称前加一个.
					var a = $('.red'); // 所有节点包含`class="red"`都将返回
					// 例如:
					// <div class="red">...</div>
					// <p class="green red">...</p>
				通常很多节点有多个class，我们可以查找同时包含red和green的节点
					var a = $('.red.green'); // 注意没有空格！
					// 符合条件的节点：
					// <div class="red green">...</div>
					// <div class="blue green red">...</div>
			按属性查找
				一个DOM节点除了id和class外还可以有很多属性
					var email = $('[name=email]'); // 找出<??? name="email">
					var passwordInput = $('[type=password]'); // 找出<??? type="password">
					var a = $('[items="A B"]'); // 找出<??? items="A B">
				当属性的值包含空格等特殊字符时，需要用双引号括起来
				按属性查找还可以使用前缀查找或者后缀查找
					var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM
					// 例如: name="icon-1", name="icon-2"
					var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM
					// 例如: name="startswith", name="endswith"
				这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响
					var icons = $('[class^="icon-"]'); // 找出所有class包含至少一个以`icon-`开头的DOM
					// 例如: class="icon-clock", class="abc icon-home"
			组合查找
				组合查找就是把上述简单选择器组合起来使用
				如果我们查找$('[name=email]')，很可能把表单外的<div name="email">也找出来，但我们只希望查找<input>，就可以这么写
					var emailInput = $('input[name=email]'); // 不会找出<div name="email">
				同样的，根据tag和class来组合查找也很常见
					var tr = $('tr.red'); // 找出<tr class="red ...">...</tr>
			多项选择器
				多项选择器就是把多个选择器用,组合起来一块选
					$('p,div'); // 把<p>和<div>都选出来
					$('p.red,p.green'); // 把<p class="red">和<p class="green">都选出来
				注意
					选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素
						<p class="red green">不会被上面的$('p.red,p.green')选择两次
			练习
				使用jQuery选择器分别选出指定元素：
					仅选择JavaScript
					仅选择Erlang
					选择JavaScript和Erlang
					选择所有编程语言
					选择名字input
					选择邮件和名字input
					
					<!-- HTML结构 -->
					<div id="test-jquery">
						<p id="para-1" class="color-red">JavaScript</p>
						<p id="para-2" class="color-green">Haskell</p>
						<p class="color-red color-green">Erlang</p>
						<p name="name" class="color-black">Python</p>
						<form class="test-form" target="_blank" action="#0" onsubmit="return false;">
							<legend>注册新用户</legend>
							<fieldset>
								<p><label>名字: <input name="name"></label></p>
								<p><label>邮件: <input name="email"></label></p>
								<p><label>口令: <input name="password" type="password"></label></p>
								<p><button type="submit">注册</button></p>
							</fieldset>
						</form>
					</div>
					
					'use strict';
					selected = $("#para-1");
					selected = $('.color-red.color-green');
					selected = $('.color-red');
					selected = $('[class^=color-]');
					selected = $('input[name=name]');
					selected = $('input[name=name],[name=email]');
					
					// 高亮结果:
					if (!(selected instanceof jQuery)) {
						return alert('不是有效的jQuery对象!');
					}
					$('#test-jquery').find('*').css('background-color', '');
					selected.css('background-color', '#ffd351');
		层级选择器(Descendant Selector)
			除了基本的选择器外，jQuery的层级选择器更加灵活，也更强大
			因为DOM的结构就是层级结构，所以我们经常要根据层级关系进行选择
			如果两个DOM元素具有层级关系，就可以用$('ancestor descendant')来选择，层级之间用空格隔开
				<!-- HTML结构 -->
				<div class="testing">
					<ul class="lang">
						<li class="lang-javascript">JavaScript</li>
						<li class="lang-python">Python</li>
						<li class="lang-lua">Lua</li>
					</ul>
				</div>
				要选出JavaScript，可以用层级选择器：
					$('ul.lang li.lang-javascript'); // [<li class="lang-javascript">JavaScript</li>]
					$('div.testing li.lang-javascript'); // [<li class="lang-javascript">JavaScript</li>]
				因为<div>和<ul>都是<li>的祖先节点，所以上面两种方式都可以选出相应的<li>节点
				要选择所有的<li>节点，用：
					$('ul.lang li');
			这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，避免了页面其他不相关的元素
				$('form[name=upload] input');
				把选择范围限定在name属性为upload的表单里。如果页面有很多表单，其他表单的<input>不会被选择
			多层选择也是允许的
				$('form.test p input'); // 在form表单选择被<p>包含的<input>
			子选择器(Child Selector)
				子选择器$('parent>child')类似层级选择器，但是限定了层级关系必须是父子关系，<child>节点必须是<parent>节点的直属子节点
					$('ul.lang>li.lang-javascript'); // 可以选出[<li class="lang-javascript">JavaScript</li>]
					$('div.testing>li.lang-javascript'); // [], 无法选出，因为<div>和<li>不构成父子关系
			过滤器(Filter)
				过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素
					$('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点
					$('ul.lang li:first-child'); // 仅选出JavaScript
					$('ul.lang li:last-child'); // 仅选出Lua
					$('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始
					$('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素
					$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素
			表单相关
				针对表单元素，jQuery还有一组特殊的选择器
					:input：可以选择<input>，<textarea>，<select>和<button>；
					:file：可以选择<input type="file">，和input[type=file]一样；
					:checkbox：可以选择复选框，和input[type=checkbox]一样；
					:radio：可以选择单选框，和input[type=radio]一样；
					:focus：可以选择当前输入焦点的元素，例如把光标放到一个<input>上，用$('input:focus')就可以选出；
					:checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$('input[type=radio]:checked')；
					:enabled：可以选择可以正常输入的<input>、<select>等，也就是没有灰掉的输入；
					:disabled：和enabled正好相反，选择那些不能输入的
				此外，jQuery还有很多有用的选择器
					例如，选出可见的或隐藏的元素
						$('div:visible'); // 所有可见的div
						$('div:hidden'); // 所有隐藏的div
				练习
					针对如下HTML结构：
						<!-- HTML结构 -->
						<div class="test-selector">
							<ul class="test-lang">
								<li class="lang-javascript">JavaScript</li>
								<li class="lang-python">Python</li>
								<li class="lang-lua">Lua</li>
							</ul>
							<ol class="test-lang">
								<li class="lang-swift">Swift</li>
								<li class="lang-java">Java</li>
								<li class="lang-c">C</li>
							</ol>
						</div>
					选出相应的内容并观察效果：
						'use strict';
						var selected = null;
						// 分别选择所有语言，所有动态语言，所有静态语言，JavaScript，Lua，C等:
						selected = $('div.test-selector li')
						selected = $('ul.test-lang li')
						selected = $('ol.test-lang li')
						selected = $('ul.test-lang li.lang-javascript')
						selected = $('ul.test-lang li:last-child')
						selected = $('ol.test-lang li:nth-child(3)')
						
						// 高亮结果:
						if (!(selected instanceof jQuery)) {
							return alert('不是有效的jQuery对象!');
						}
						$('#test-jquery').find('*').css('background-color', '');
						selected.css('background-color', '#ffd351');
			查找和过滤
				通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤
				最常见的查找是在某个节点的所有子节点中查找，使用find()方法，它本身又接收一个任意的选择器
						<!-- HTML结构 -->
						<ul class="lang">
							<li class="js dy">JavaScript</li>
							<li class="dy">Python</li>
							<li id="swift">Swift</li>
							<li class="dy">Scheme</li>
							<li name="haskell">Haskell</li>
						</ul>
					用find()查找：
						var ul = $('ul.lang'); // 获得<ul>
						var dy = ul.find('.dy'); // 获得JavaScript, Python, Scheme
						var swf = ul.find('#swift'); // 获得Swift
						var hsk = ul.find('[name=haskell]'); // 获得Haskell
					如果要从当前节点开始向上查找，使用parent()方法：
						var swf = $('#swift'); // 获得Swift
						var parent = swf.parent(); // 获得Swift的上层节点<ul>
						var a = swf.parent('div.red'); // 从Swift的父节点开始向上查找，直到找到某个符合条件的节点并返回
					对于位于同一层级的节点，可以通过next()和prev()方法，例如：
						var swift = $('#swift');
						swift.next(); // Scheme
						swift.next('[name=haskell]'); // Haskell，因为Haskell是后续第一个符合选择器条件的节点

						swift.prev(); // Python
						swift.prev('.js'); // JavaScript，因为JavaScript是往前第一个符合选择器条件的节点
				过滤
					和函数式编程的map、filter类似，jQuery对象也有类似的方法
					filter()方法可以过滤掉不符合选择器条件的节点
						var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
						var a = langs.filter('.dy'); // 拿到JavaScript, Python, Scheme
					或者传入一个函数，要特别注意函数内部的this被绑定为DOM对象，不是jQuery对象
						var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
						langs.filter(function () {
							return this.innerHTML.indexOf('S') === 0; // 返回S开头的节点
						}); // 拿到Swift, Scheme
					map()方法把一个jQuery对象包含的若干DOM节点转化为其他对象
						var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
						var arr = langs.map(function () {
							return this.innerHTML;
						}).get(); // 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']
					此外，一个jQuery对象如果包含了不止一个DOM节点，first()、last()和slice()方法可以返回一个新的jQuery对象，把不需要的DOM节点去掉
						var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
						var js = langs.first(); // JavaScript，相当于$('ul.lang li:first-child')
						var haskell = langs.last(); // Haskell, 相当于$('ul.lang li:last-child')
						var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致
				练习
					对于下面的表单：
						<form id="test-form" action="#0" onsubmit="return false;">
							<p><label>Name: <input name="name"></label></p>
							<p><label>Email: <input name="email"></label></p>
							<p><label>Password: <input name="password" type="password"></label></p>
							<p>Gender: <label><input name="gender" type="radio" value="m" checked> Male</label> <label><input name="gender" type="radio" value="f"> Female</label></p>
							<p><label>City: <select name="city">
								<option value="BJ" selected>Beijing</option>
								<option value="SH">Shanghai</option>
								<option value="CD">Chengdu</option>
								<option value="XM">Xiamen</option>
							</select></label></p>
							<p><button type="submit">Submit</button></p>
						</form>
					输入值后，用jQuery获取表单的JSON字符串，key和value分别对应每个输入的name和相应的value，例如：{"name":"Michael","email":...}

						'use strict';
						var json = null;
						json={};
						var input = $('#test-form :input[type!=submit]');
						input.map(function(){
						  var value = this.value;
						  if(this.type === "radio"){
							if(this.checked){
							  value =  $(this).parent().get(0).innerText;
							}
						  }else if(this.name == 'city'){
							var children =   $(this).find('option');
							for(var x in children){
							  if(children[x].selected){
								value = children[x].innerText;
							  }
							}
						  }
						  json[this.name] = value;
						});
						json=JSON.stringify(json);
						
						// 显示结果:
						if (typeof(json) === 'string') {
							alert(json);
						}
						else {
							alert('json变量不是string!');
						}
		操作DOM
			jQuery的选择器很强大，用起来又简单又灵活，拿到了jQuery对象，到底要干什么？
				答案当然是操作对应的DOM节点
			修改Text和HTML
				jQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本
				例如
					<!-- HTML结构 -->
					<ul id="test-ul">
						<li class="js">JavaScript</li>
						<li name="book">Java &amp; JavaScript</li>
					</ul>
					分别获取文本和HTML：
						$('#test-ul li[name=book]').text(); // 'Java & JavaScript'
						$('#test-ul li[name=book]').html(); // 'Java &amp; JavaScript'
				如何设置文本或HTML？
					无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作
						'use strict';
						var j1 = $('#test-ul li.js');
						var j2 = $('#test-ul li[name=book]');
						j1.html('<span style="color: red">JavaScript</span>');
						j2.text('JavaScript & ECMAScript');
				一个jQuery对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上
					$('#test-ul li').text('JS'); // 是不是两个节点都变成了JS？
				jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。
				即使选择器没有返回任何DOM节点，调用jQuery对象的方法仍然不会报错
					// 如果不存在id为not-exist的节点：
					$('#not-exist').text('Hello'); // 代码不报错，没有节点被设置为'Hello'
			修改CSS
				jQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便
					<!-- HTML结构 -->
					<ul id="test-css">
						<li class="lang dy"><span>JavaScript</span></li>
						<li class="lang"><span>Java</span></li>
						<li class="lang dy"><span>Python</span></li>
						<li class="lang"><span>Swift</span></li>
						<li class="lang dy"><span>Scheme</span></li>
					</ul>
					要高亮显示动态语言，调用jQuery对象的css('name', 'value')方法
						'use strict';
						$('#test-css li.dy>span').css('background-color', '#ffd351').css('color', 'red');
				注意，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行链式调用，非常方便
				jQuery对象的css()方法
					var div = $('#test-div');
					div.css('color'); // '#000033', 获取CSS属性
					div.css('color', '#336699'); // 设置CSS属性
					div.css('color', ''); // 清除CSS属性
				为了和JavaScript保持一致，CSS属性可以用'background-color'和'backgroundColor'两种格式
				css()方法将作用于DOM节点的style属性，具有最高优先级
				如果要修改class属性，可以用jQuery提供的下列方法
					var div = $('#test-div');
					div.hasClass('highlight'); // false， class是否包含highlight
					div.addClass('highlight'); // 添加highlight这个class
					div.removeClass('highlight'); // 删除highlight这个class
				练习：分别用css()方法和addClass()方法高亮显示JavaScript
					<!-- HTML结构 -->
					<style>
					.highlight {
						color: #dd1144;
						background-color: #ffd351;
					}
					</style>

					<div id="test-highlight-css">
						<ul>
							<li class="py"><span>Python</span></li>
							<li class="js"><span>JavaScript</span></li>
							<li class="sw"><span>Swift</span></li>
							<li class="hk"><span>Haskell</span></li>
						</ul>
					</div>
					
					'use strict';
					var div = $('#test-highlight-css');
					// TODO:
					//div.find('.js').css('background-color', '#ffd351').css('color', '#dd1144')
					div.find('.js').addClass('highlight');
			显示和隐藏DOM
				要隐藏一个DOM，我们可以设置CSS的display属性为none，利用css()方法就可以实现
				不过，要显示这个DOM就需要恢复原有的display属性，这就得先记下来原有的display属性到底是block还是inline还是别的值
				考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供show()和hide()方法
					var a = $('a[target=_blank]');
					a.hide(); // 隐藏
					a.show(); // 显示
				注意，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的
			获取DOM信息
				利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码
					// 浏览器可视窗口大小:
					$(window).width(); // 800
					$(window).height(); // 600

					// HTML文档大小:
					$(document).width(); // 800
					$(document).height(); // 3500

					// 某个div的大小:
					var div = $('#test-div');
					div.width(); // 600
					div.height(); // 300
					div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效
					div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效
				attr()和removeAttr()方法用于操作DOM节点的属性
					// <div id="test-div" name="Test" start="1">...</div>
					var div = $('#test-div');
					div.attr('data'); // undefined, 属性不存在
					div.attr('name'); // 'Test'
					div.attr('name', 'Hello'); // div的name属性变为'Hello'
					div.removeAttr('name'); // 删除name属性
					div.attr('name'); // undefined
				prop()方法和attr()类似，但是HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种
					例如：
						<input id="test-radio" type="radio" name="test" checked value="1">
					等价于：
						<input id="test-radio" type="radio" name="test" checked="checked" value="1">
					attr()和prop()对于属性checked处理有所不同
						var radio = $('#test-radio');
						radio.attr('checked'); // 'checked'
						radio.prop('checked'); // true
					prop()返回值更合理一些。不过，用is()方法判断更好
						var radio = $('#test-radio');
						radio.is(':checked'); // true
					类似的属性还有selected，处理时最好用is(':selected')
			操作表单
				对于表单元素，jQuery对象统一提供val()方法获取和设置对应的value属性
					/*
						<input id="test-input" name="email" value="">
						<select id="test-select" name="city">
							<option value="BJ" selected>Beijing</option>
							<option value="SH">Shanghai</option>
							<option value="SZ">Shenzhen</option>
						</select>
						<textarea id="test-textarea">Hello</textarea>
					*/
					var
						input = $('#test-input'),
						select = $('#test-select'),
						textarea = $('#test-textarea');

					input.val(); // 'test'
					input.val('abc@example.com'); // 文本框的内容已变为abc@example.com

					select.val(); // 'BJ'
					select.val('SH'); // 选择框已变为Shanghai

					textarea.val(); // 'Hello'
					textarea.val('Hi'); // 文本区域已更新为'Hi'
				可见，一个val()就统一了各种输入框的取值和赋值的问题
			修改DOM结构
				直接使用浏览器提供的API对DOM结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码
				有了jQuery，我们就专注于操作jQuery对象本身，底层的DOM操作由jQuery完成就可以了，这样一来，修改DOM也大大简化
				添加DOM
					要添加新的DOM节点，除了通过jQuery的html()这种暴力方法外，还可以用append()方法
						<div id="test-div">
							<ul>
								<li><span>JavaScript</span></li>
								<li><span>Python</span></li>
								<li><span>Swift</span></li>
							</ul>
						</div>
					如何向列表新增一个语言？
						首先要拿到<ul>节点
							var ul = $('#test-div>ul');
						然后，调用append()传入HTML片段
							ul.append('<li><span>Haskell</span></li>');
					除了接受字符串，append()还可以传入原始的DOM对象，jQuery对象和函数对象
						// 创建DOM对象:
						var ps = document.createElement('li');
						ps.innerHTML = '<span>Pascal</span>';
						// 添加DOM对象:
						ul.append(ps);

						// 添加jQuery对象:
						ul.append($('#scheme'));

						// 添加函数对象:
						ul.append(function (index, html) {
							return '<li><span>Language - ' + index + '</span></li>';
						});
						传入函数时，要求返回一个字符串、DOM对象或者jQuery对象。
						因为jQuery的append()可能作用于一组DOM节点，只有传入函数才能针对每个DOM生成不同的子节点。
						append()把DOM添加到最后，prepend()则把DOM添加到最前。
						另外注意，如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，也就是说，用append()，你可以移动一个DOM节点
					如果要把新节点插入到指定位置？例如，JavaScript和Python之间
						先定位到JavaScript，然后用after()方法
							var js = $('#test-div>ul>li:first-child');
							js.after('<li><span>Lua</span></li>');
						也就是说，同级节点可以用after()或者before()方法
				删除节点
					要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以
					如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点
						var li = $('#test-div>ul>li');
						li.remove(); // 所有<li>全被删除
				练习
					除了列出的3种语言外，请再添加Pascal、Lua和Ruby，然后按字母顺序排序节点
						<!-- HTML结构 -->
						<div id="test-div">
							<ul>
								<li><span>JavaScript</span></li>
								<li><span>Python</span></li>
								<li><span>Swift</span></li>
							</ul>
						</div>
						
						'use strict';
						var lan = $('#test-div>ul');
						lan.append('<li><span>Pascal</span></li>');
						lan.append('<li><span>Lua</span></li>');
						lan.append('<li><span>Ruby</span></li>');

						//获取li并排序
						var lis=$('#test-div>ul>li');
						lis.sort(function(x,y){
							return x.innerText>y.innerText;
						});
						//添加排序后的li
						lan.append(lis);
						
						// 测试:
						;(function () {
							var s = $('#test-div>ul>li').map(function () {
								return $(this).text();
							}).get().join(',');
							if (s === 'JavaScript,Lua,Pascal,Python,Ruby,Swift') {
								alert('测试通过!');
							} else {
								alert('测试失败: ' + s);
							}
						})();
		事件
			因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码
			浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。
			如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。
			由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。
				/* HTML:
				 *
				 * <a id="test-link" href="#0">点我试试</a>
				 *
				 */

				// 获取超链接的jQuery对象:
				var a = $('#test-link');
				a.on('click', function () {
					alert('Hello!');
				});
			on方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数
			另一种更简化的写法是直接调用click()方法：
				a.click(function () {
					alert('Hello!');
				});
			两者完全等价
			jQuery能够绑定的事件
				鼠标事件
					click: 鼠标单击时触发；
					dblclick：鼠标双击时触发；
					mouseenter：鼠标进入时触发；
					mouseleave：鼠标移出时触发；
					mousemove：鼠标在DOM内部移动时触发；
					hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。
				键盘事件
					键盘事件仅作用在当前焦点的DOM上，通常是<input>和<textarea>。

					keydown：键盘按下时触发；
					keyup：键盘松开时触发；
					keypress：按一次键后触发。

				其他事件
					focus：当DOM获得焦点时触发；
					blur：当DOM失去焦点时触发；
					change：当<input>、<select>或<textarea>的内容改变时触发；
					submit：当<form>提交时触发；
					ready：当页面被载入并且DOM树完成初始化后触发。
					
					其中，ready仅作用于document对象。
					由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码
					假设我们想给一个<form>表单绑定submit事件，下面的代码没有预期的效果
						<html>
						<head>
							<script>
								// 代码有误:
								$('#testForm).on('submit', function () {
									alert('submit!');
								});
							</script>
						</head>
						<body>
							<form id="testForm">
								...
							</form>
						</body>
					因为JavaScript在此执行的时候，<form>尚未载入浏览器，所以$('#testForm)返回[]，并没有绑定事件到任何DOM上
					所以我们自己的初始化代码必须放到document对象的ready事件中，保证DOM已完成初始化
						<html>
						<head>
							<script>
								$(document).on('ready', function () {
									$('#testForm).on('submit', function () {
										alert('submit!');
									});
								});
							</script>
						</head>
						<body>
							<form id="testForm">
								...
							</form>
						</body>
					这样写就没有问题了。因为相关代码会在DOM树初始化后再执行
			由于ready事件使用非常普遍，所以可以这样简化：
				$(document).ready(function () {
					// on('submit', function)也可以简化:
					$('#testForm).submit(function () {
						alert('submit!');
					});
				});
			甚至还可以再简化为：
				$(function () {
					// init...
				});
			事件参数
				有些事件，如mousemove和keypress，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义
				所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息
					$(function () {
						$('#testMouseMoveDiv').mousemove(function (e) {
							$('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY);
						});
					});
			取消绑定
				一个已被绑定的事件可以解除绑定，通过off('click', function)实现
					function hello() {
						alert('hello!');
					}

					a.click(hello); // 绑定事件

					// 10秒钟后解除绑定:
					setTimeout(function () {
						a.off('click', hello);
					}, 10000);
				需要特别注意的是，下面这种写法是无效的：
					// 绑定事件:
					a.click(function () {
						alert('hello!');
					});

					// 解除绑定:
					a.off('click', function () {
						alert('hello!');
					});
				这是因为两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象
				off('click', function () {...})无法移除已绑定的第一个匿名函数
				为了实现移除效果，可以使用off('click')一次性移除已绑定的click事件的所有处理函数。
				同理，无参数调用off()一次性移除已绑定的所有类型的事件处理函数
			事件触发条件
				一个需要注意的问题是，事件的触发总是由用户操作引发的
				例如，我们监控文本框的内容改动
					var input = $('#test-input');
					input.change(function () {
						console.log('changed...');
					});
				当用户在文本框中输入时，就会触发change事件
				但是，如果用JavaScript代码去改动文本框的值，将不会触发change事件
					var input = $('#test-input');
					input.val('change it!'); // 无法触发change事件
				有些时候，我们希望用代码触发change事件，可以直接调用无参数的change()方法来触发该事件
					var input = $('#test-input');
					input.val('change it!');
					input.change(); // 触发change事件
				input.change()相当于input.trigger('change')，它是trigger()方法的简写
			浏览器安全限制
				在浏览器中，有些JavaScript代码只有在用户触发下才能执行，例如，window.open()函数
					// 无法弹出新窗口，将被浏览器屏蔽:
					$(function () {
						window.open('/');
					});
				这些“敏感代码”只能由用户操作来触发
					var button1 = $('#testPopupButton1');
					var button2 = $('#testPopupButton2');

					function popupTestWindow() {
						window.open('/');
					}

					button1.click(function () {
						popupTestWindow();
					});

					button2.click(function () {
						// 不立刻执行popupTestWindow()，100毫秒后执行:
						setTimeout(popupTestWindow, 100);
					});
				当用户点击button1时，click事件被触发，由于popupTestWindow()在click事件处理函数内执行，这是浏览器允许的
				而button2的click事件并未立刻执行popupTestWindow()，延迟执行的popupTestWindow()将被浏览器拦截
			练习
				对如下的Form表单：
					<!-- HTML结构 -->
					<form id="test-form" action="test">
						<legend>请选择想要学习的编程语言：</legend>
						<fieldset>
							<p><label class="selectAll"><input type="checkbox"> <span class="selectAll">全选</span><span class="deselectAll">全不选</span></label> <a href="#0" class="invertSelect">反选</a></p>
							<p><label><input type="checkbox" name="lang" value="javascript"> JavaScript</label></p>
							<p><label><input type="checkbox" name="lang" value="python"> Python</label></p>
							<p><label><input type="checkbox" name="lang" value="ruby"> Ruby</label></p>
							<p><label><input type="checkbox" name="lang" value="haskell"> Haskell</label></p>
							<p><label><input type="checkbox" name="lang" value="scheme"> Scheme</label></p>
							<p><button type="submit">Submit</button></p>
						</fieldset>
					</form>
				绑定合适的事件处理函数，实现以下逻辑：
					当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选”；
					当用户去掉“全不选”时，自动不选中所有语言；
					当用户点击“反选”时，自动把所有语言状态反转（选中的变为未选，未选的变为选中）；
					当用户把所有语言都手动勾上时，“全选”被自动勾上，并变为“全不选”；
					当用户手动去掉选中至少一种语言时，“全不选”自动被去掉选中，并变为“全选”。

					'use strict';

					var
						form = $('#test-form'),
						langs = form.find('[name=lang]'),
						selectAll = form.find('label.selectAll :checkbox'),
						selectAllLabel = form.find('label.selectAll span.selectAll'),
						deselectAllLabel = form.find('label.selectAll span.deselectAll'),
						invertSelect = form.find('a.invertSelect');

					// 重置初始化状态:
					form.find('*').show().off();
					form.find(':checkbox').prop('checked', false).off();
					deselectAllLabel.hide();
					// 拦截form提交事件:
					form.off().submit(function (e) {
						e.preventDefault();
						alert(form.serialize());
					});

					// TODO:绑定事件
					//全选或全不选
					selectAll.click(function(e) {
						if (selectAll.is(':checked')) {
							langs.prop('checked', true);
							deselectAllLabel.show();
							selectAllLabel.hide();
						}
						else {
							langs.prop('checked', false);
							deselectAllLabel.hide();
							selectAllLabel.show();
						}     
					});

					//反选
					invertSelect.click(function(e) {
						langs.click();
					});

					//手动选
					langs.click(function(e) {

						if (selectAll.is(':checked')) {
							selectAll.prop('checked', false);
							deselectAllLabel.hide();
							selectAllLabel.show();
						}
						else {
							var status = true;
							langs.each(function() {
								if (!$(this).is(':checked')) {
									status = false;
								}
							});
							if (status) {
								selectAll.prop('checked', true);
								deselectAllLabel.show();
								selectAllLabel.hide();
							}     
						}
					});

					// 测试:
					alert('请测试功能是否正常。');
		动画
			用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了
			但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了
			使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码
			jQuery内置的几种动画样式
				show / hide
					直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画
						var div = $('#test-show-hide');
						div.hide(3000); // 在3秒钟内逐渐消失
					时间以毫秒为单位，但也可以是'slow'，'fast'这些字符串
						var div = $('#test-show-hide');
						div.show('slow'); // 在0.6秒钟内逐渐显示
					toggle()方法则根据当前状态决定是show()还是hide()
				slideUp / slideDown
					show()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的
					slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作
						var div = $('#test-slide');
						div.slideUp(3000); // 在3秒钟内逐渐向上消失
				fadeIn / fadeOut
					fadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断设置DOM元素的opacity属性来实现，而fadeToggle()则根据元素是否可见来决定下一步动作
						var div = $('#test-fade');
						div.fadeOut('slow'); // 在0.6秒内淡出
			自定义动画
				animate()，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值
					var div = $('#test-animate');
					div.animate({
						opacity: 0.25,
						width: '256px',
						height: '256px'
					}, 3000); // 在3秒钟内CSS过渡到设定值
				animate()还可以再传入一个函数，当动画结束时，该函数将被调用
					var div = $('#test-animate');
					div.animate({
						opacity: 0.25,
						width: '256px',
						height: '256px'
					}, 3000, function () {
						console.log('动画已结束');
						// 恢复至初始状态:
						$(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');
					});
				实际上这个回调函数参数对于基本动画也是适用的
			串行动画
				jQuery的动画效果还可以串行执行，通过delay()方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单
					var div = $('#test-animates');
					// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小
					div.slideDown(2000)
					   .delay(1000)
					   .animate({
						   width: '256px',
						   height: '256px'
					   }, 2000)
					   .delay(1000)
					   .animate({
						   width: '128px',
						   height: '128px'
					   }, 2000);
					}
					</script>
				因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。
			为什么有的动画没有效果
				你可能会遇到，有的动画如slideUp()根本没有效果
					因为jQuery动画的原理是逐渐改变CSS的值，如height从100px逐渐变为0。
					但是很多不是block性质的DOM元素，对它们设置height根本就不起作用，所以动画也就没有效果
				此外，jQuery也没有实现对background-color的动画效果
					用animate()设置background-color也没有效果
					这种情况下可以使用CSS3的transition实现动画效果
			练习
				在表格删除一行的时候添加一个淡出的动画效果
					'use strict';
					function deleteFirstTR() {
						var tr = $('#test-table>tbody>tr:visible').first();
						tr.fadeOut('slow', function(){$(this).remove();})
					}
					deleteFirstTR();
					
		AJAX
			用JavaScript写AJAX主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦
			用jQuery的相关对象来处理AJAX，不但不需要考虑浏览器问题，代码也能大大简化
			jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求
			ajax(url, settings)函数需要接收一个URL和一个可选的settings对象
				常用的选项如下
					async：是否异步执行AJAX请求，默认为true，千万不要指定为false；
					method：发送的Method，缺省为'GET'，可指定为'POST'、'PUT'等；
					contentType：发送POST请求的格式，默认值为'application/x-www-form-urlencoded; charset=UTF-8'，也可以指定为text/plain、application/json；
					data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；
					headers：发送的额外的HTTP头，必须是一个object；
					dataType：接收的数据格式，可以指定为'html'、'xml'、'json'、'text'等，缺省情况下根据响应的Content-Type猜测。
				发送一个GET请求，并返回一个JSON格式的数据
					var jqxhr = $.ajax('/api/categories', {
						dataType: 'json'
					});
					// 请求已经发送了
				如何用回调函数处理返回的数据和出错时的响应呢？
					'use strict';
					function ajaxLog(s) {
						var txt = $('#test-response-text');
						txt.val(txt.val() + '\n' + s);
					}

					$('#test-response-text').val('');

					var jqxhr = $.ajax('/api/categories', {
						dataType: 'json'
					}).done(function (data) {
						ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));
					}).fail(function (xhr, status) {
						ajaxLog('失败: ' + xhr.status + ', 原因: ' + status);
					}).always(function () {
						ajaxLog('请求完成: 无论成功或失败都会调用');
					});
			get
				由于GET请求最常见，所以jQuery提供了get()方法
					var jqxhr = $.get('/path/to/resource', {
						name: 'Bob Lee',
						check: 1
					});
					第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是：
						/path/to/resource?name=Bob%20Lee&check=1
					这样我们就不用关心如何用URL编码并构造一个query string了
			post
				post()和get()类似，但是传入的第二个参数默认被序列化为application/x-www-form-urlencoded
					var jqxhr = $.post('/path/to/resource', {
						name: 'Bob Lee',
						check: 1
					});
					实际构造的数据name=Bob%20Lee&check=1作为POST的body被发送。
			getJSON
				由于JSON用得越来越普遍，所以jQuery也提供了getJSON()方法来快速通过GET获取一个JSON对象
					var jqxhr = $.getJSON('/path/to/resource', {
						name: 'Bob Lee',
						check: 1
					}).done(function (data) {
						// data已经被解析为JSON对象了
					});
			安全限制
				jQuery的AJAX完全封装的是JavaScript的AJAX操作，所以它的安全限制和前面讲的用JavaScript写AJAX完全一样。
				如果需要使用JSONP，可以在ajax()中设置jsonp: 'callback'，让jQuery实现JSONP跨域加载数据。
		扩展
			jQuery内置的方法永远不可能满足所有的需求
				比如，我们想要高亮显示某些DOM元素，用jQuery可以这么实现
					$('span.hl').css('backgroundColor', '#fffceb').css('color', '#d85030');
					$('p a.hl').css('backgroundColor', '#fffceb').css('color', '#d85030');
				总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个highlight()方法？
					$('span.hl').highlight();
					$('p a.hl').highlight();
				可以扩展jQuery来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写jQuery插件
			编写jQuery插件
				给jQuery对象绑定一个新方法是通过扩展$.fn对象实现的
					1，让我们来编写第一个扩展――highlight1()
							$.fn.highlight1 = function () {
								// this已绑定为当前jQuery对象:
								this.css('backgroundColor', '#fffceb').css('color', '#d85030');
								return this;
							}
						函数内部的this在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法
						对于如下的HTML结构：
							<!-- HTML结构 -->
							<div id="test-highlight1">
								<p>什么是<span>jQuery</span></p>
								<p><span>jQuery</span>是目前最流行的<span>JavaScript</span>库。</p>
							</div>
						测试一下highlight1()的效果：
							'use strict';
							$('#test-highlight1 span').highlight1();
						为什么最后要return this;？
							因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去
							$('span.hl').highlight1().slideDown();
							不然，用户调用的时候，就不得不把上面的代码拆成两行
					2，这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？
						可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的highlight2()
							$.fn.highlight2 = function (options) {
								// 要考虑到各种情况:
								// options为undefined
								// options只有部分key
								var bgcolor = options && options.backgroundColor || '#fffceb';
								var color = options && options.color || '#d85030';
								this.css('backgroundColor', bgcolor).css('color', color);
								return this;
							}
						对于如下HTML结构：
							<!-- HTML结构 -->
							<div id="test-highlight2">
								<p>什么是<span>jQuery</span> <span>Plugin</span></p>
								<p>编写<span>jQuery</span> <span>Plugin</span>可以用来扩展<span>jQuery</span>的功能。</p>
							</div>
						测一下带参数的highlight2()
							'use strict';
							$('#test-highlight2 span').highlight2({
								backgroundColor: '#00a8e6',
								color: '#ffffff'
							});
							对于默认值的处理，我们用了一个简单的&&和||短路操作符，总能得到一个有效的值
						另一种方法是使用jQuery提供的辅助方法$.extend(target, obj1, obj2, ...)
							它把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高
								// 把默认值和用户传入的options合并到对象{}中并返回:
								var opts = $.extend({}, {
									backgroundColor: '#00a8e6',
									color: '#ffffff'
								}, options);
					3，每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的highlight2()？
							也就是说，我们设定的默认值应该能允许用户修改
							默认值放哪比较合适？
								放全局变量肯定不合适，最佳地点是$.fn.highlight2这个函数对象本身
						最终版的highlight()终于诞生了
							$.fn.highlight = function (options) {
								// 合并默认值和用户设定值:
								var opts = $.extend({}, $.fn.highlight.defaults, options);
								this.css('backgroundColor', opts.backgroundColor).css('color', opts.color);
								return this;
							}

							// 设定默认值:
							$.fn.highlight.defaults = {
								color: '#d85030',
								backgroundColor: '#fff8de'
							}
						用户使用时，只需一次性设定默认值
							$.fn.highlight.defaults.color = '#fff';
							$.fn.highlight.defaults.backgroundColor = '#000';
						然后就可以非常简单地调用highlight()了
						对如下的HTML结构：
							<!-- HTML结构 -->
							<div id="test-highlight">
								<p>如何编写<span>jQuery</span> <span>Plugin</span></p>
								<p>编写<span>jQuery</span> <span>Plugin</span>，要设置<span>默认值</span>，并允许用户修改<span>默认值</span>，或者运行时传入<span>其他值</span>。</p>
							</div>
						实测一下修改默认值的效果：
							'use strict';
							$.fn.highlight.defaults.color = '#659f13';
							$.fn.highlight.defaults.backgroundColor = '#f2fae3';

							$('#test-highlight p:first-child span').highlight();

							$('#test-highlight p:last-child span').highlight({
								color: '#dd1144'
							});
					编写一个jQuery插件的原则
						1，给$.fn绑定函数，实现插件的代码逻辑；
						2，插件函数最后要return this;以支持链式调用；
						3，插件函数要有默认值，绑定在$.fn.<pluginName>.defaults上；
						4，用户在调用时可传入设定值以便覆盖默认值。
			针对特定元素的扩展
				jQuery对象的有些方法只能作用在特定DOM元素上，比如submit()方法只能针对form
				如果我们编写的扩展只能针对某些类型的DOM元素，应该怎么写？
					jQuery的选择器支持filter()方法来过滤，可以借助这个方法来实现针对特定元素的扩展
						举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做？
							先写出用户调用的代码
								$('#main a').external();
							然后按照上面的方法编写一个external扩展
								$.fn.external = function () {
									// return返回的each()返回结果，支持链式调用:
									return this.filter('a').each(function () {
										// 注意: each()内部的回调函数的this绑定为DOM本身!
										var a = $(this);
										var url = a.attr('href');
										if (url && (url.indexOf('http://')===0 || url.indexOf('https://')===0)) {
											a.attr('href', '#0')
											 .removeAttr('target')
											 .append(' <i class="uk-icon-external-link"></i>')
											 .click(function () {
												if(confirm('你确定要前往' + url + '？')) {
													window.open(url);
												}
											});
										}
									});
								}
							对如下的HTML结构
								<!-- HTML结构 -->
								<div id="test-external">
									<p>如何学习<a href="http://jquery.com">jQuery</a>？</p>
									<p>首先，你要学习<a href="/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000">JavaScript</a>，并了解基本的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML</a>。</p>
								</div>
							实测外链效果
								'use strict';
								$('#test-external a').external();
				扩展jQuery对象的功能十分简单，但是我们要遵循jQuery的原则，编写的扩展方法能支持链式调用、具备默认值和过滤特定元素，使得扩展方法看上去和jQuery本身的方法没有什么区别
				
	underscore
		JavaScript是函数式编程语言，支持高阶函数和闭包。函数式编程非常强大，可以写出非常简洁的代码
		可是Object没有这些方法。此外，低版本的浏览器例如IE6～8也没有这些方法，怎么办？
			方法一，自己把这些方法添加到Array.prototype中，然后给Object.prototype也加上mapObject()等类似的方法。
			方法二，直接找一个成熟可靠的第三方开源库，使用统一的函数来实现map()、filter()这些操作
		选择的第三方库就是underscore
			underscore则提供了一套完善的函数式编程的接口，让我们更方便地在JavaScript中实现函数式编程
			underscore会把自身绑定到唯一的全局变量_上
				用underscore实现map()操作如下
					'use strict';
					_.map([1, 2, 3], (x) => x * x); // [1, 4, 9]
					咋一看比直接用Array.map()要麻烦一点，可是underscore的map()还可以作用于Object：
					'use strict';
					_.map({ a: 1, b: 2, c: 3 }, (v, k) => k + '=' + v); // ['a=1', 'b=2', 'c=3']
		Collections
			underscore为集合类对象提供了一致的接口
			集合类是指Array和Object，暂不支持Map和Set
			map/filter
				和Array的map()与filter()类似，但是underscore的map()和filter()可以作用于Object
				当作用于Object时，传入的函数为function (value, key)，第一个参数接收value，第二个参数接收key
					'use strict';
					var obj = {
						name: 'bob',
						school: 'No.1 middle school',
						address: 'xueyuan road'
					};
					
					var upper = _.map(obj, function (value, key) {
						return value.toUpperCase();
					});
					alert(JSON.stringify(upper));
					//["BOB","NO.1 MIDDLE SCHOOL","XUEYUAN ROAD"]
					
					var upper = _.mapObject(obj, function (value, key) {
						return value.toUpperCase();
					});
					alert(JSON.stringify(upper));
					//{"name":"BOB","school":"NO.1 MIDDLE SCHOOL","address":"XUEYUAN ROAD"}
			every / some
				当集合的所有元素都满足条件时，_.every()函数返回true，当集合的至少一个元素满足条件时，_.some()函数返回true
					'use strict';
					// 所有元素都大于0？
					_.every([1, 4, 7, -3, -9], (x) => x > 0); // false
					// 至少一个元素大于0？
					_.some([1, 4, 7, -3, -9], (x) => x > 0); // true
				当集合是Object时，我们可以同时获得value和key
					'use strict';
					var obj = {
						name: 'bob',
						school: 'No.1 middle school',
						address: 'xueyuan road'
					};
					// 判断key和value是否全部是小写
					var r1 = _.every(obj, function (value, key) {
						return value.toLowerCase() === value && key.toLowerCase() === key;
					});
					var r2 = _.some(obj, function (value, key) {
						return value.toLowerCase() === value && key.toLowerCase() === key;
					});
					alert('every key-value are lowercase: ' + r1 + '\nsome key-value are lowercase: ' + r2);
			max / min
				这两个函数直接返回集合中最大和最小的数
					'use strict';
					var arr = [3, 5, 7, 9];
					_.max(arr); // 9
					_.min(arr); // 3

					// 空集合会返回-Infinity和Infinity，所以要先判断集合不为空：
					_.max([])
					//-Infinity
					_.min([])
					//Infinity
				注意，如果集合是Object，max()和min()只作用于value，忽略掉key
					'use strict';
					_.max({ a: 1, b: 2, c: 3 }); // 3
			groupBy
				groupBy()把集合的元素按照key归类，key由传入的函数返回
					'use strict';
					var scores = [20, 81, 75, 40, 91, 59, 77, 66, 72, 88, 99];
					var groups = _.groupBy(scores, function (x) {
						if (x < 60) {
							return 'C';
						} else if (x < 80) {
							return 'B';
						} else {
							return 'A';
						}
					});
					// 结果:
					// {
					//   A: [81, 91, 88, 99],
					//   B: [75, 77, 66, 72],
					//   C: [20, 40, 59]
					// }
			shuffle / sample
				shuffle()用洗牌算法随机打乱一个集合
					'use strict';
					// 注意每次结果都不一样：
					_.shuffle([1, 2, 3, 4, 5, 6]); // [3, 5, 4, 6, 2, 1]
				sample()则是随机选择一个或多个元素
					'use strict';
					// 注意每次结果都不一样：
					// 随机选1个：
					_.sample([1, 2, 3, 4, 5, 6]); // 2
					// 随机选3个：
					_.sample([1, 2, 3, 4, 5, 6], 3); // [6, 1, 4]
		Arrays
			underscore为Array提供了许多工具类方法，可以更方便快捷地操作Array
			first / last
				这两个函数分别取第一个和最后一个元素
					'use strict';
					var arr = [2, 4, 6, 8];
					_.first(arr); // 2
					_.last(arr); // 8
			flatten
				flatten()接收一个Array，无论这个Array里面嵌套了多少个Array，flatten()最后都把它们变成一个一维数组
					'use strict';
					_.flatten([1, [2], [3, [[4], [5]]]]); // [1, 2, 3, 4, 5]
			zip / unzip
				zip()把两个或多个数组的所有元素按索引对齐，然后按索引合并成新数组
					例如，你有一个Array保存了名字，另一个Array保存了分数，现在，要把名字和分数给对上，用zip()轻松实现
						'use strict';
						var names = ['Adam', 'Lisa', 'Bart'];
						var scores = [85, 92, 59];
						_.zip(names, scores);
						// [['Adam', 85], ['Lisa', 92], ['Bart', 59]]
				unzip()则是反过来
					'use strict';
					var namesAndScores = [['Adam', 85], ['Lisa', 92], ['Bart', 59]];
					_.unzip(namesAndScores);
					// [['Adam', 'Lisa', 'Bart'], [85, 92, 59]]
			object
				有时候你会想，与其用zip()，为啥不把名字和分数直接对应成Object呢？用object()函数
					'use strict';
					var names = ['Adam', 'Lisa', 'Bart'];
					var scores = [85, 92, 59];
					_.object(names, scores);
					// {Adam: 85, Lisa: 92, Bart: 59}
				注意_.object()是一个函数，不是JavaScript的Object对象
			range
				range()让你快速生成一个序列，不再需要用for循环实现了
					'use strict';
					// 从0开始小于10:
					_.range(10); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

					// 从1开始小于11：
					_.range(1, 11); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

					// 从0开始小于30，步长5:
					_.range(0, 30, 5); // [0, 5, 10, 15, 20, 25]

					// 从0开始大于-10，步长-1:
					_.range(0, -10, -1); // [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
		Functions
			因为underscore本来就是为了充分发挥JavaScript的函数式编程特性，所以也提供了大量JavaScript本身没有的高阶函数
			bind
				bind()有什么用？
					错误
						'use strict';
						console.log('Hello, world!');
						// 输出'Hello, world!'

						var log = console.log;
						log('Hello, world!');
						// Uncaught TypeError: Illegal invocation
					你想用log()取代console.log()，按照上面的做法是不行的
					因为直接调用log()传入的this指针是undefined
					必须这么用
						'use strict';
						var log = console.log;
						// 调用call并传入console对象作为this:
						log.call(console, 'Hello, world!')
						// 输出Hello, world!
					bind()可以帮我们把console对象直接绑定在log()的this指针上，以后调用log()就可以直接正常调用
						'use strict';
						var log = _.bind(console.log, console);
						log('Hello, world!');
						// 输出Hello, world!
			partial
				partial()就是为一个函数创建偏函数
				偏函数是什么？
					例子
						假设我们要计算x^y，这时只需要调用Math.pow(x, y)就可以
						假设我们经常计算2^y，每次都写Math.pow(2, y)就比较麻烦
						如果创建一个新的函数能直接这样写pow2N(y)就好了
						这个新函数pow2N(y)就是根据Math.pow(x, y)创建出来的偏函数，它固定住了原函数的第一个参数（始终为2）
							'use strict';
							var pow2N = _.partial(Math.pow, 2);
							pow2N(3); // 8
							pow2N(5); // 32
							pow2N(10); // 1024
						如果我们不想固定第一个参数，想固定第二个参数怎么办？
							可以用_作占位符，固定住第二个参数
								比如，希望创建一个偏函数cube(x)，计算x3
									'use strict';
									var cube = _.partial(Math.pow, _, 3);
									cube(3); // 27
									cube(5); // 125
									cube(10); // 1000
				可见，创建偏函数的目的是将原函数的某些参数固定住，可以降低新函数调用的难度
			memoize
				如果一个函数调用开销很大，我们就可能希望能把结果缓存下来，以便后续调用时直接获得结果
					比如，计算阶乘就比较耗时
						'use strict';
						function factorial(n) {
							console.log('start calculate ' + n + '!...');
							var s = 1, i = n;
							while (i > 1) {
								s = s * i;
								i --;
							}
							console.log(n + '! = ' + s);
							return s;
						}

						factorial(10); // 3628800
						// 注意控制台输出:
						// start calculate 10!...
						// 10! = 3628800
					用memoize()就可以自动缓存函数计算的结果
						'use strict';
						var factorial = _.memoize(function(n) {
							console.log('start calculate ' + n + '!...');
							var s = 1, i = n;
							while (i > 1) {
								s = s * i;
								i --;
							}
							console.log(n + '! = ' + s);
							return s;
						});

						// 第一次调用:
						factorial(10); // 3628800
						// 注意控制台输出:
						// start calculate 10!...
						// 10! = 3628800

						// 第二次调用:
						factorial(10); // 3628800
						// 控制台没有输出
					对于相同的调用，比如连续两次调用factorial(10)，第二次调用并没有计算，而是直接返回上次计算后缓存的结果
					不过，当你计算factorial(9)的时候，仍然会重新计算
					可以对factorial()进行改进，让其递归调用
						'use strict';
						var factorial = _.memoize(function(n) {
							console.log('start calculate ' + n + '!...');
							if (n < 2) {
								return 1;
							}
							return n * factorial(n - 1);
						});

						factorial(10); // 3628800
						// 输出结果说明factorial(1)~factorial(10)都已经缓存了:
						// start calculate 10!...
						// start calculate 9!...
						// start calculate 8!...
						// start calculate 7!...
						// start calculate 6!...
						// start calculate 5!...
						// start calculate 4!...
						// start calculate 3!...
						// start calculate 2!...
						// start calculate 1!...

						factorial(9); // 362880
						// console无输出
			once
				顾名思义，once()保证某个函数执行且仅执行一次
				如果你有一个方法叫register()，用户在页面上点两个按钮的任何一个都可以执行的话，就可以用once()保证函数仅调用一次，无论用户点击多少次
					'use strict';
					var register = _.once(function () {
						alert('Register ok!');
					});

					// 测试效果:
					register();
					register();
					register();
			delay
				delay()可以让一个函数延迟执行，效果和setTimeout()是一样的，但是代码明显简单
					'use strict';
					// 2秒后调用alert():
					_.delay(alert, 2000);
				如果要延迟调用的函数有参数，把参数也传进去
					'use strict';
					var log = _.bind(console.log, console);
					_.delay(log, 2000, 'Hello,', 'world!');
					// 2秒后打印'Hello, world!':
		Objects
			和Array类似，underscore也提供了大量针对Object的函数
			keys / allKeys
				keys()可以非常方便地返回一个object自身所有的key，但不包含从原型链继承下来的
					'use strict';
					function Student(name, age) {
						this.name = name;
						this.age = age;
					}

					var xiaoming = new Student('小明', 20);
					_.keys(xiaoming); // ['name', 'age']
				allKeys()除了object自身的key，还包含从原型链继承下来的
					'use strict';
					function Student(name, age) {
						this.name = name;
						this.age = age;
					}
					Student.prototype.school = 'No.1 Middle School';
					var xiaoming = new Student('小明', 20);
					_.allKeys(xiaoming); // ['name', 'age', 'school']
			values
				和keys()类似，values()返回object自身但不包含原型链继承的所有值
					'use strict';
					var obj = {
						name: '小明',
						age: 20
					};

					_.values(obj); // ['小明', 20]
				注意，没有allValues()
			mapObject
				mapObject()就是针对object的map版本
					'use strict';
					var obj = { a: 1, b: 2, c: 3 };
					// 注意传入的函数签名，value在前，key在后:
					_.mapObject(obj, (v, k) => 100 + v); // { a: 101, b: 102, c: 103 }
			invert
				invert()把object的每个key-value来个交换，key变成value，value变成key
					'use strict';
					var obj = {
						Adam: 90,
						Lisa: 85,
						Bart: 59
					};
					_.invert(obj); // { '59': 'Bart', '85': 'Lisa', '90': 'Adam' }
			extend / extendOwn
				extend()把多个object的key-value合并到第一个object并返回
					'use strict';
					var a = {name: 'Bob', age: 20};
					_.extend(a, {age: 15}, {age: 88, city: 'Beijing'}); // {name: 'Bob', age: 88, city: 'Beijing'}
					// 变量a的内容也改变了：
					a; // {name: 'Bob', age: 88, city: 'Beijing'}
				注意：如果有相同的key，后面的object的value将覆盖前面的object的value
				extendOwn()和extend()类似，但获取属性时忽略从原型链继承下来的属性
			clone
				如果我们要复制一个object对象，就可以用clone()方法，它会把原有对象的所有属性都复制到新的对象中
					'use strict';
					var source = {
						name: '小明',
						age: 20,
						skills: ['JavaScript', 'CSS', 'HTML']
					};
					var copied = _.clone(source);
					alert(JSON.stringify(copied, null, '  '));
				注意，clone()是“浅复制”。所谓“浅复制”就是说，两个对象相同的key所引用的value其实是同一对象
					source.skills === copied.skills; // true
				也就是说，修改source.skills会影响copied.skills
			isEqual
				isEqual()对两个object进行深度比较，如果内容完全相同，则返回true
					'use strict';
					var o1 = { name: 'Bob', skills: { Java: 90, JavaScript: 99 }};
					var o2 = { name: 'Bob', skills: { JavaScript: 99, Java: 90 }};

					o1 === o2; // false
					_.isEqual(o1, o2); // true
				isEqual()其实对Array也可以比较
					'use strict';
					var o1 = ['Bob', { skills: ['Java', 'JavaScript'] }];
					var o2 = ['Bob', { skills: ['Java', 'JavaScript'] }];

					o1 === o2; // false
					_.isEqual(o1, o2); // true
		Chaining
			jQuery支持链式调用
				$('a').attr('target', '_blank')
					  .append(' <i class="uk-icon-external-link"></i>')
					  .click(function () {});
			如果我们有一组操作，用underscore提供的函数，写出来像这样
				_.filter(_.map([1, 4, 9, 16, 25], Math.sqrt), x => x % 2 === 1);
				// [1, 3, 5]
			能不能写成链式调用？
				underscore提供了把对象包装成能进行链式调用的方法，就是chain()函数
					_.chain([1, 4, 9, 16, 25])
					 .map(Math.sqrt)
					 .filter(x => x % 2 === 1)
					 .value();
					// [1, 3, 5]
				因为每一步返回的都是包装对象，所以最后一步的结果需要调用value()获得最终结果
	Node.js
		模块
			xxx.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块
				hello.js
					'use strict';
					var s = 'Hello';

					function greet(name) {
						console.log(s + ', ' + name + '!');
					}

					module.exports = greet;
			其他模块怎么使用hello模块的这个greet函数呢？
				main.js
					'use strict';
					// 引入hello模块
					var greet = require('./hello');

					var s = 'Michael';

					greet(s); // Hello, Michael!
			在main.js中用Node提供的require函数引入hello模块
			在hello.js中用module.exports = greet;输出的greet函数
		基本模块
			global
				JavaScript有且仅有一个全局对象，在浏览器中，叫window对象
				在Node.js环境中，也有唯一的全局对象，叫global
					global.console
					Console {
					  log: [Function: bound ],
					  info: [Function: bound ],
					  warn: [Function: bound ],
					  error: [Function: bound ],
					  dir: [Function: bound ],
					  time: [Function: bound ],
					  timeEnd: [Function: bound ],
					  trace: [Function: bound trace],
					  assert: [Function: bound ],
					  Console: [Function: Console] }
			process
				process也是Node.js提供的一个对象，它代表当前Node.js进程
					process === global.process;
						true
					process.version;
						'v6.9.1'
					process.platform;
						'win32'
					process.arch;
						'ia32'
					process.cwd(); //返回当前工作目录
						'D:\\Develop-Software\\GitRepo\\learn-js\\module'
				JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。
				Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了
			fs
				Node.js内置的fs模块就是文件系统模块，负责读写文件
				fs模块同时提供了异步和同步的方法
				同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件
				而异步读取不用等待IO操作，但代码较麻烦
				异步读文件
					'use strict';
					var fs = require('fs');

					fs.readFile('sample.txt', 'utf-8', function (err, data) {
						if (err) {
							console.log(err);
						} else {
							console.log(data);
						}
					});
					注意，sample.txt文件必须在当前目录下，且文件编码为utf-8
					传入的回调函数接收两个参数
						当正常读取时，err参数为null，data参数为读取到的String
						当读取发生错误时，err参数代表一个错误对象，data为undefined
					如果要读取的文件不是文本文件，而是二进制文件，怎么办？
						'use strict';
						var fs = require('fs');

						fs.readFile('sample.png', function (err, data) {
							if (err) {
								console.log(err);
							} else {
								console.log(data);
								console.log(data.length + ' bytes');
							}
						});
						当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象
						在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）
						Buffer对象可以和String作转换
							把一个Buffer对象转换成String
								// Buffer -> String
								var text = data.toString('utf-8');
								console.log(text);
							把一个String转换成Buffer
								// String -> Buffer
								var buf = new Buffer(text, 'utf-8');
								console.log(buf);
				同步读文件
					同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果
						'use strict';
						var fs = require('fs');

						var data = fs.readFileSync('sample.txt', 'utf-8');
						console.log(data);
					如果同步读取文件发生错误，则需要用try...catch捕获该错误
						try {
							var data = fs.readFileSync('sample.txt', 'utf-8');
							console.log(data);
						} catch (err) {
							// 出错了
						}
				写文件
					异步
						'use strict';
						var fs = require('fs');

						var data = 'Hello, Node.js';
						fs.writeFile('output.txt', data, function (err) {
							if (err) {
								console.log(err);
							} else {
								console.log('ok.');
							}
						});
						writeFile()的参数依次为文件名、数据和回调函数
						如果传入的数据是String，默认按UTF-8编码写入文本文件
						如果传入的参数是Buffer，则写入的是二进制文件
					同步
						'use strict';
						var fs = require('fs');

						var data = 'Hello, Node.js';
						fs.writeFileSync('output.txt', data);
				stat
					使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息
						'use strict';
						var fs = require('fs');

						fs.stat('sample.txt', function (err, stat) {
							if (err) {
								console.log(err);
							} else {
								// 是否是文件:
								console.log('isFile: ' + stat.isFile());
								// 是否是目录:
								console.log('isDirectory: ' + stat.isDirectory());
								if (stat.isFile()) {
									// 文件大小:
									console.log('size: ' + stat.size);
									// 创建时间, Date对象:
									console.log('birth time: ' + stat.birthtime);
									// 修改时间, Date对象:
									console.log('modified time: ' + stat.mtime);
								}
							}
						});
						//运行结果
						isFile: true
						isDirectory: false
						size: 181
						birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)
						modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST)
				由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码
				否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程
				服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。




							



			
			
			
			
			
			
			
		
			
