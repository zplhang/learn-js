JavaScript
	快速入门
		JavaScript代码可以直接嵌在网页的任何地方，通常放在<head>中
		方法一：用<script>...</script>
			<html>
			<head>
				<script>
					alert('Hello World!');
				</script>
			</head>
			<body>
			  ...
			</body>
			</html>
		方法二：将JavaScript代码放到一个单独的.js文件，通过<script src="..."></script>引入这个文件
			<html>
			<head>
			  <script src="/static/js/abc.js"></script>
			</head>
			<body>
			  ...
			</body>
			</html>
		基础语法
			JavaScript严格区分大小写
			语法和Java语言类似，每个语句以;结束，语句块用{...}
			注意花括号{...}内的语句具有缩进，通常是4个空格；非必须，建议使用缩进，有助于理解代码层次
			{...}可以嵌套，嵌套层级没有限制，但是过多的嵌套会增加看懂代码的难度
			//开头直到行末的字符被视为行注释，/*...*/把多行字符包裹起来是块注释
		数据类型
			Number
				不区分整数和浮点数
					123
					0.456
					1.2345e3
					-99
					NaN
					Infinity
				有时候用十六进制表示整数更方便
					0xff00
					0xa5b4c3d2
			字符串
				单引号或者双引号括起来的任意文本
				如果'本身也是一个字符，那就可以用""括起来
				如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识
					'I\'m \"OK\"!';
				转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\
				ASCII字符可以以\x##形式的十六进制表示
					'\x41'; // 完全等同于 'A'
				用\u####表示一个Unicode字符
					'\u4e2d\u6587'; // 完全等同于 '中文'
				多行字符串
					多行字符串用\n写起来比较费事，最新的ES6标准新增了一种多行字符串的表示方法，用`...`表示
						`这是一个
						多行
						字符串`;
				模板字符串
					要把多个字符串连接起来，可以用+号连接
						var name = '小明';
						var age = 20;
						var message = '你好, ' + name + ', 你今年' + age + '岁了!';
						alert(message);
					有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串
						var name = '小明';
						var age = 20;
						var message = `你好, ${name}, 你今年${age}岁了!`;
						alert(message);
				操作字符串
					1，求字符串长度
						var s = 'Hello, world!';
						s.length; // 13
					2，获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始
						var s = 'Hello, world!';

						s[0]; // 'H'
						s[6]; // ' '
						s[7]; // 'w'
						s[12]; // '!'
						s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined
					特别注意
						字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果
							var s = 'Test';
							s[0] = 'X';
							alert(s); // s仍然为'Test'
					其他常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串
					3，把一个字符串全部变为大写toUpperCase
						var s = 'Hello';
						s.toUpperCase(); // 返回'HELLO'
					4，把一个字符串全部变为小写toLowerCase
						var s = 'Hello';
						var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower
						lower; // 'hello'
					5，搜索指定字符串出现的位置indexOf
						var s = 'hello, world';
						s.indexOf('world'); // 返回7
						s.indexOf('World'); // 没有找到指定的子串，返回-1
					6，返回指定索引区间的子串substring
						var s = 'hello, world'
						s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
						s.substring(7); // 从索引7开始到结束，返回'world'
						
						
			布尔值
				只有true、false两种值
				可以直接用true、false表示布尔值，也可以通过布尔运算计算出来
				&&，与运算，只有所有都为true，&&运算结果才是true
				||，或运算，只要其中有一个为true，||运算结果就是true
				!，非运算，是一个单目运算符，把true变成false，false变成true
				比较运算符
					>
					>=
					==
				注意
					1,
						==，自动转换数据类型再比较
							false == 0; //true
						===，不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较
							false === 0; //false
					2,
						NaN这个特殊的Number与所有其他值都不相等，包括它自己
							NaN === NaN; //false
						唯一能判断NaN的方法是通过isNaN()函数
							isNaN(NaN); //true
					3,
						注意浮点数的相等比较
							1 / 3 === (1 - 2 / 3); // false
						浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数
						要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值
							Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
			null和undefined
				null表示一个“空”的值
				它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而null表示“空”。
				undefined表示值未定义
				区分undefined和null的意义不大。大多数情况下，我们都应该用null
				undefined仅仅在判断函数参数是否传递的情况下有用。
			数组
				数组是一组按顺序排列的集合，集合的每个值称为元素
				JavaScript的数组可以包括任意数据类型
					[1, 2, 3.14, 'Hello', null, true];
				另一种创建数组的方法是通过Array()函数实现
					new Array(1, 2, 3); 
				数组的元素可以通过索引来访问，索引的起始值为0
				Array的长度，直接访问length属性
					var arr = [1, 2, 3.14, 'Hello', null, true];
					arr.length; // 6
					注意：直接给Array的length赋一个新的值会导致Array大小的变化
						var arr = [1, 2, 3];
						arr.length; // 3
						arr.length = 6;
						arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
						arr.length = 2;
						arr; // arr变为[1, 2]
					Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array
						var arr = ['A', 'B', 'C'];
						arr[1] = 99;
						arr; // arr现在变为['A', 99, 'C']
					注意：如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化
						var arr = [1, 2, 3];
						arr[5] = 'x';
						arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
					大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。
					在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界
				相关函数
					1，indexOf(搜索一个指定的元素的位置)
						var arr = [10, 20, '30', 'xyz'];
						arr.indexOf(10); // 元素10的索引为0
						arr.indexOf(20); // 元素20的索引为1
						arr.indexOf(30); // 元素30没有找到，返回-1
						arr.indexOf('30'); // 元素'30'的索引为2
					2，slice(截取Array的部分元素，然后返回一个新的Array)
						var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
						arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
						arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
						注意：slice()的起止参数包括开始索引，不包括结束索引
						不给slice()传递任何参数，它就会从头到尾截取所有元素
							var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
							var aCopy = arr.slice();
							aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
							aCopy === arr; // false
					3，push和pop(push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉)
						var arr = [1, 2];
						arr.push('A', 'B'); // 返回Array新的长度: 4
						arr; // [1, 2, 'A', 'B']
						arr.pop(); // pop()返回'B'
						arr; // [1, 2, 'A']
						arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
						arr; // []
						arr.pop(); // 空数组继续pop不会报错，而是返回undefined
						arr; // []
					4，unshift和shift(unshift()往Array的头部添加若干元素，shift()方法则把Array的第一个元素删掉)
						var arr = [1, 2];
						arr.unshift('A', 'B'); // 返回Array新的长度: 4
						arr; // ['A', 'B', 1, 2]
						arr.shift(); // 'A'
						arr; // ['B', 1, 2]
						arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
						arr; // []
						arr.shift(); // 空数组继续shift不会报错，而是返回undefined
						arr; // []
					5，sort(对当前Array进行排序)
						var arr = ['B', 'C', 'A'];
						arr.sort();
						arr; // ['A', 'B', 'C']
					6，reverse(反转)
						var arr = ['one', 'two', 'three'];
						arr.reverse(); 
						arr; // ['three', 'two', 'one']
					7，splice(修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素)
						var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
						// 从索引2开始删除3个元素,然后再添加两个元素:
						arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
						arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
						// 只删除,不添加:
						arr.splice(2, 2); // ['Google', 'Facebook']
						arr; // ['Microsoft', 'Apple', 'Oracle']
						// 只添加,不删除:
						arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
						arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
					8，concat(当前的Array和另一个Array连接起来，并返回一个新的Array)
						var arr = ['A', 'B', 'C'];
						var added = arr.concat([1, 2, 3]);
						added; // ['A', 'B', 'C', 1, 2, 3]
						arr; // ['A', 'B', 'C']
						注意：concat()方法并没有修改当前Array，而是返回了一个新的Array
						concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里
							var arr = ['A', 'B', 'C'];
							arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
					9，join(把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串)
						var arr = ['A', 'B', 'C', 1, 2, 3];
						arr.join('-'); // 'A-B-C-1-2-3'
						如果Array的元素不是字符串，将自动转换为字符串后再连接
				多维数组
					如果数组的某个元素又是一个Array，则可以形成多维数组
						var arr = [[1, 2, 3], [400, 500, 600], '-'];
												
					
			对象
				一组由键-值组成的无序集合
					var person = {
						name: 'Bob',
						age: 20,
						tags: ['js', 'web', 'mobile'],
						city: 'Beijing',
						hasCar: true,
						zipcode: null
					};
				对象的键都是字符串类型，值可以是任意数据类型，每个键又称为对象的属性
				获取一个对象的属性，我们用 对象变量.属性名 的方式
					person.name; // 'Bob'
					person.zipcode; // null
				如果属性名包含特殊字符，就必须用''括起来
					var xiaohong = {
						name: '小红',
						'middle-school': 'No.1 Middle School'
					};
					xiaohong的属性名middle-school不是一个有效的变量，就需要用''括起来。
					访问这个属性也无法使用.操作符，必须用['xxx']来访问
						xiaohong['middle-school']; // 'No.1 Middle School'
						xiaohong['name']; // '小红'
						xiaohong.name; // '小红'
				如果访问一个不存在的属性会返回什么呢？
					访问不存在的属性不报错，而是返回undefined
					var xiaoming = {
						name: '小明'
					};
					xiaoming.age; // undefined
				对象是动态类型，你可以自由地给一个对象添加或删除属性
					var xiaoming = {
						name: '小明'
					};
					xiaoming.age; // undefined
					xiaoming.age = 18; // 新增一个age属性
					xiaoming.age; // 18
					delete xiaoming.age; // 删除age属性
					xiaoming.age; // undefined
					delete xiaoming['name']; // 删除name属性
					xiaoming.name; // undefined
					delete xiaoming.school; // 删除一个不存在的school属性也不会报错
				如果我们要检测xiaoming是否拥有某一属性，可以用in操作符
					var xiaoming = {
						name: '小明',
						birth: 1990,
						school: 'No.1 Middle School',
						height: 1.70,
						weight: 65,
						score: null
					};
					'name' in xiaoming; // true
					'grade' in xiaoming; // false
				注意：如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的
					'toString' in xiaoming; // true
					因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性
				要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法
					var xiaoming = {
						name: '小明'
					};
					xiaoming.hasOwnProperty('name'); // true
					xiaoming.hasOwnProperty('toString'); // false
					
			变量
				用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头
				变量名也不能是JavaScript的关键字，如if、while等。
				声明一个变量用var语句
					var a; // 申明了变量a，此时a的值为undefined
					var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1
					var s_007 = '007'; // s_007是一个字符串
					var Answer = true; // Answer是一个布尔值true
					var t = null; // t的值是null
				变量名也可以用中文，但可能会引起麻烦
				使用等号=对变量进行赋值
				可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var声明一次
					var a = 123; // a的值是整数123
					a = 'ABC'; // a变为字符串
				变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言
				静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言
					int a = 123; // a是整数类型变量，类型用int声明
					a = "ABC"; // 错误：不能把字符串赋给整型变量
				和静态语言相比，动态语言更灵活
			strict模式
				JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量
				这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量
					i = 10; // i现在是全局变量
				在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果
				使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内，同名变量在不同的函数体内互不冲突
				为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式
				在strict模式下，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误
				启用strict模式的方法是在JavaScript代码的第一行写上：'use strict';
				不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript
					'use strict';
					// 如果浏览器支持strict模式，
					// 下面的代码将报ReferenceError错误:
					abc = 'Hello, world';
					alert(abc);
					
		条件判断
			使用if () { ... } else { ... }来进行条件判断
			else语句是可选的
			如果语句块只包含一条语句，那么可以省略{}；但是建议永远都要写上{}
			如果还要更细致地判断条件，可以使用多个if...else...的组合
				var age = 3;
				if (age >= 18) {
					alert('adult');
				} else if (age >= 6) {
					alert('teenager');
				} else {
					alert('kid');
				}
			注意，if...else...语句的执行特点是二选一，在多个if...else...语句中，如果某个条件成立，则后续就不再继续判断
			JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true
		循环
			JavaScript的循环有两种，一种是for循环，另一种while循环
			for
				通过初始条件、结束条件和递增条件来循环执行语句块
					var x = 0;
					var i;
					for (i=1; i<=10000; i++) {
						x = x + i;
					}
					x; // 50005000
				for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环
			for...in
				可以把一个对象的所有属性依次循环出来
					var o = {
						name: 'Jack',
						age: 20,
						city: 'Beijing'
					};
					for (var key in o) {
						alert(key); // 'name', 'age', 'city'
					}
				要过滤掉对象继承的属性，用hasOwnProperty()来实现
					var o = {
						name: 'Jack',
						age: 20,
						city: 'Beijing'
					};
					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							alert(key); // 'name', 'age', 'city'
						}
					}
				由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引
					var a = ['A', 'B', 'C'];
					for (var i in a) {
						alert(i); // '0', '1', '2'
						alert(a[i]); // 'A', 'B', 'C'
					}
					注意，for ... in对Array的循环得到的是String而不是Number
			while
				只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环
					比如我们要计算100以内所有奇数之和，可以用while循环实现
						var x = 0;
						var n = 99;
						while (n > 0) {
							x = x + n;
							n = n - 2;
						}
						x; // 2500
			do ... while
				和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件
					var n = 0;
					do {
						n = n + 1;
					} while (n < 100);
					n; // 100
				do { ... } while()循环体会至少执行1次
		Map和Set
			JavaScript的对象有个小问题，就是键必须是字符串.实际上Number或者其他数据类型作为键也是非常合理的
			为了解决这个问题，最新的ES6规范引入了新的数据类型Map
			Map
				一组键值对的结构，具有极快的查找速度
					var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
					m.get('Michael'); // 95
				初始化Map需要一个二维数组，或者直接初始化一个空Map
					var m = new Map(); // 空Map
					m.set('Adam', 67); // 添加新的key-value
					m.set('Bob', 59);
					m.has('Adam'); // 是否存在key 'Adam': true
					m.get('Adam'); // 67
					m.delete('Adam'); // 删除key 'Adam'
					m.get('Adam'); // undefined
				由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值覆盖
					var m = new Map();
					m.set('Adam', 67);
					m.set('Adam', 88);
					m.get('Adam'); // 88
			Set
				一组key的集合，但不存储value
				由于key不能重复，所以，在Set中，没有重复的key
				要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set
					var s1 = new Set(); // 空Set
					var s2 = new Set([1, 2, 3]); // 含1, 2, 3
				重复元素在Set中自动被过滤
					var s = new Set([1, 2, 3, 3, '3']);
					s; // Set {1, 2, 3, "3"}
				通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果
				通过delete(key)方法可以删除元素
					var s = new Set([1, 2, 3]);
					s; // Set {1, 2, 3}
					s.delete(3);
					s; // Set {1, 2}
		iterable
			遍历Array可以采用下标循环，遍历Map和Set就无法使用下标
			为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型
			具有iterable类型的集合可以通过新的for ... of循环来遍历
				var a = ['A', 'B', 'C'];
				var s = new Set(['A', 'B', 'C']);
				var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
				for (var x of a) { // 遍历Array
					alert(x);
				}
				for (var x of s) { // 遍历Set
					alert(x);
				}
				for (var x of m) { // 遍历Map
					alert(x[0] + '=' + x[1]);
				}
			for ... of循环和for ... in循环有何区别？
				for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称
					一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。
					当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果
					var a = ['A', 'B', 'C'];
					a.name = 'Hello';
					for (var x in a) {
						alert(x); // '0', '1', '2', 'name'
					}
					for ... in循环将把name包括在内，但Array的length属性却不包括在内
				for ... of循环则完全修复了这些问题，它只循环集合本身的元素
					var a = ['A', 'B', 'C'];
					a.name = 'Hello';
					for (var x of a) {
						alert(x); // 'A', 'B', 'C'
					}
			更好的方式是直接使用iterable内置的forEach方法
				以Array为例
					var a = ['A', 'B', 'C'];
					a.forEach(function (element, index, array) {
						// element: 指向当前元素的值
						// index: 指向当前索引
						// array: 指向Array对象本身
						alert(element);
					});
				Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身
					var s = new Set(['A', 'B', 'C']);
					s.forEach(function (element, sameElement, set) {
						alert(element);
					});
				Map的回调函数参数依次为value、key和map本身
					var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
					m.forEach(function (value, key, map) {
						alert(value);
					});
				如果对某些参数不感兴趣，可以忽略它们
					例如，只需要获得Array的element
						var a = ['A', 'B', 'C'];
						a.forEach(function (element) {
							alert(element);
						});
	
	函数
		代码抽象方式
		定义
			方式一
				function abs(x) {
					if (x >= 0) {
						return x;
					} else {
						return -x;
					}
				}
			function指出这是一个函数定义；
			abs是函数的名称；
			(x)括号内列出函数的参数，多个参数以,分隔；
			{ ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句
			函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回
			如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined
			函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量
			
			方式二
				var abs = function (x) {
					if (x >= 0) {
						return x;
					} else {
						return -x;
					}
				};
			在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名
			但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数
		函数调用
			JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数
				abs(10, 'blablabla'); // 返回10
				abs(-9, 'haha', 'hehe', null); // 返回9
			传入的参数比定义的少也没有问题
				abs(); // 返回NaN
				此时abs(x)函数的参数x将收到undefined，计算结果为NaN
				要避免收到undefined，可以对参数进行检查
					function abs(x) {
						if (typeof x !== 'number') {
							throw 'Not a number';
						}
						if (x >= 0) {
							return x;
						} else {
							return -x;
						}
					}
			arguments
				JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数
				arguments类似Array但它不是一个Array
					function foo(x) {
						alert(x); // 10
						for (var i=0; i<arguments.length; i++) {
							alert(arguments[i]); // 10, 20, 30
						}
					}
					foo(10, 20, 30);
				利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值
					function abs() {
						if (arguments.length === 0) {
							return 0;
						}
						var x = arguments[0];
						return x >= 0 ? x : -x;
					}

					abs(); // 0
					abs(10); // 10
					abs(-9); // 9
				实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法：
					// foo(a[, b], c)
					// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
					function foo(a, b, c) {
						if (arguments.length === 2) {
							// 实际拿到的参数是a和b，c为undefined
							c = b; // 把b赋给c
							b = null; // b变为默认值
						}
						// ...
					}
			rest
				ES6标准引入了rest参数，获得额外的rest参数
					function foo(a, b, ...rest) {
						console.log('a = ' + a);
						console.log('b = ' + b);
						console.log(rest);
					}

					foo(1, 2, 3, 4, 5);
					// 结果:
					// a = 1
					// b = 2
					// Array [ 3, 4, 5 ]

					foo(1);
					// 结果:
					// a = 1
					// b = undefined
					// Array []
				rest参数只能写在最后，前面用...标识
		变量作用域
			如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量
				'use strict';

				function foo() {
					var x = 1;
					x = x + 1;
				}

				x = x + 2; // ReferenceError! 无法在函数体外引用变量x
			如果两个不同的函数各自申明了同一个变量，它们互相独立，互不影响
				'use strict';

				function foo() {
					var x = 1;
					x = x + 1;
				}

				function bar() {
					var x = 'A';
					x = x + 'B';
				}
			函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行
				'use strict';

				function foo() {
					var x = 1;
					function bar() {
						var y = x + 1; // bar可以访问foo的变量x!
					}
					var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
				}
			如果内部函数和外部函数的变量名重名怎么办？
				函数在查找变量时从自身函数定义开始，从“内”向“外”查找
				如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量
			变量提升
				函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部
					'use strict';
					function foo() {
						var x = 'Hello, ' + y;
						alert(x);
						var y = 'Bob';
					}
					foo();
					语句var x = 'Hello, ' + y;并不报错，原因是变量y在稍后申明了
					但是alert显示Hello, undefined，说明变量y的值为undefined
					JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值
					严格遵守“在函数内部首先申明所有变量”这一规则
						function foo() {
							var
								x = 1, // x初始化为1
								y = x + 1, // y初始化为2
								z, i; // z和i为undefined
							// 其他语句:
							for (i=0; i<100; i++) {
								...
							}
						}
			全局作用域
				JavaScript默认有一个全局对象window
				全局作用域的变量实际上被绑定到window的一个属性
					'use strict';
					var course = 'Learn JavaScript';
					alert(course); // 'Learn JavaScript'
					alert(window.course); // 'Learn JavaScript'
				变量方式var foo = function () {}定义的函数实际上也是一个全局变量
				顶层函数的定义也被视为一个全局变量，并绑定到window对象
				每次直接调用的alert()函数其实也是window的一个变量
			名字空间
				不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突
				减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中
			局部作用域
				JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量
					'use strict';
					function foo() {
						for (var i=0; i<100; i++) {
							//
						}
						i += 100; // 仍然可以引用变量i
					}
				为了解决块级作用域，ES6引入了新的关键字let
				用let替代var可以申明一个块级作用域的变量
					'use strict';
					function foo() {
						var sum = 0;
						for (let i=0; i<100; i++) {
							sum += i;
						}
						i += 1; // SyntaxError
					}
			常量
				var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的
				通常用全部大写的变量来表示常量，不修改它的值
					var PI = 3.14;
				ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域
					'use strict';
					const PI = 3.14;
					PI = 3; // 某些浏览器不报错，但是无效果！
					PI; // 3.14
		方法
			在一个对象中绑定函数，称为这个对象的方法
				如果我们给xiaoming绑定一个函数
				var xiaoming = {
					name: '小明',
					birth: 1990,
					age: function () {
						var y = new Date().getFullYear();
						return y - this.birth;
					}
				};
				xiaoming.age; // function xiaoming.age()
				xiaoming.age(); // 今年调用是25,明年调用就变成26了
			绑定到对象上的函数称为方法，它在内部使用了一个this关键字
			对普通函数调用，我们通常把this绑定为null
			在一个方法内部，this是一个特殊变量，它始终指向当前对象
				function getAge() {
					var y = new Date().getFullYear();
					return y - this.birth;
				}

				var xiaoming = {
					name: '小明',
					birth: 1990,
					age: getAge
				};

				xiaoming.age(); // 25, 正常结果
				getAge(); // NaN
				如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象
				如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window
				如果这么写：
					var fn = xiaoming.age; // 先拿到xiaoming的age函数
					fn(); // NaN
				也是不行的
			要保证this指向正确，必须用obj.xxx()的形式调用！
			ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误
				'use strict';
				var xiaoming = {
					name: '小明',
					birth: 1990,
					age: function () {
						var y = new Date().getFullYear();
						return y - this.birth;
					}
				};
				var fn = xiaoming.age;
				fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
			这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置
			apply
				要指定函数的this指向哪个对象，可以用函数本身的apply方法
				接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数
					function getAge() {
						var y = new Date().getFullYear();
						return y - this.birth;
					}
					var xiaoming = {
						name: '小明',
						birth: 1990,
						age: getAge
					};
					xiaoming.age(); // 25
					getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
			call
				另一个与apply()类似的方法是call()
				区别
					apply()把参数打包成Array再传入；
					call()把参数按顺序传入
					
					比如调用Math.max(3, 5, 4)，分别用apply()和call()实现
						Math.max.apply(null, [3, 5, 4]); // 5
						Math.max.call(null, 3, 5, 4); // 5
			装饰器
				JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数
				现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了
				最佳方案是用我们自己的函数替换掉默认的parseInt()
					var count = 0;
					var oldParseInt = parseInt; // 保存原函数

					window.parseInt = function () {
						count += 1;
						return oldParseInt.apply(null, arguments); // 调用原函数
					};

					// 测试:
					parseInt('10');
					parseInt('20');
					parseInt('30');
					count; // 3
		高阶函数
			一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数
				function add(x, y, f) {
					return f(x) + f(y);
				}
				当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs
				add(-5, 6, Math.abs); // 11
			map/reduce
				map
					map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果
						function pow(x) {
							return x * x;
						}

						var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
						arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
					map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数
						var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
						arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
				reduce
					Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算
						[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
						对一个Array求和
							var arr = [1, 3, 5, 7, 9];
							arr.reduce(function (x, y) {
								return x + y;
							}); // 25
						要把[1, 3, 5, 7, 9]变换成整数13579
							var arr = [1, 3, 5, 7, 9];
							arr.reduce(function (x, y) {
								return x * 10 + y;
							}); // 13579
						不要使用JavaScript内置的parseInt()和Number()函数，利用map和reduce操作实现一个string2int()函数
							'use strict';
							function string2int(s) {
								return s.split('').map(function (x) { return x - '0';}).reduce(function(x, y) {return x * 10 + y});
							}
							// 测试:
							if (string2int('0') === 0 && string2int('12345') === 12345 && string2int('12300') === 12300) {
								if (string2int.toString().indexOf('parseInt') !== -1) {
									alert('请勿使用parseInt()!');
								} else if (string2int.toString().indexOf('Number') !== -1) {
									alert('请勿使用Number()!');
								} else {
									alert('测试通过!');
								}
							}
							else {
								alert('测试失败!');
							}
						把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字
						输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']
							'use strict';
							function normalize(arr) {
								return arr.map(function(x) { var head = x[0].toUpperCase(); var tail = x.substring(1).toLowerCase(); return head + tail;});
							}
							// 测试:
							if (normalize(['adam', 'LISA', 'barT']).toString() === ['Adam', 'Lisa', 'Bart'].toString()) {
								alert('测试通过!');
							}
							else {
								alert('测试失败!');
							}
						利用map()把字符串变成整数
							'use strict';
							var arr = ['1', '2', '3'];
							var r;
							r = arr.map(parseInt);
							alert('[' + r[0] + ', ' + r[1] + ', ' + r[2] + ']');
							结果竟然是[1, NaN, NaN]。
							原因
								由于map()接收的回调函数可以有3个参数：callback(currentValue, index, array)，通常我们仅需要第一个参数，而忽略了传入的后面两个参数
								不幸的是，parseInt(string, radix)没有忽略第二个参数
								实际执行的函数分别是：
									parseInt('1', 0); // 0, 按十进制转换
									parseInt('2', 1); // NaN, 没有一进制
									parseInt('3', 2); // NaN, 按二进制转换不允许出现3
							可以改为r = arr.map(Number);，因为Number(value)函数仅接收一个参数
							或者
								r = arr.map(function(x) { return +x;});
								js 是一种弱类型的语言，执行 +x 时会进行隐式的转换




			
			
			
			
			
		
			
